<?php
/**
 * StoreData
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * StoreData Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class StoreData implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'StoreData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'name' => 'string',
        'website' => 'string',
        'support_url' => 'string',
        'logo_url' => 'string',
        'css_url' => 'string',
        'payment_sound_url' => 'string',
        'brand_color' => 'string',
        'apply_brand_color_to_backend' => 'bool',
        'default_currency' => 'string',
        'additional_tracked_rates' => 'string[]',
        'invoice_expiration' => 'mixed',
        'refund_bolt11_expiration' => 'mixed',
        'display_expiration_timer' => 'mixed',
        'monitoring_expiration' => 'mixed',
        'speed_policy' => '\OpenAPI\Client\Model\SpeedPolicy',
        'lightning_description_template' => 'string',
        'payment_tolerance' => 'float',
        'archived' => 'bool',
        'anyone_can_create_invoice' => 'bool',
        'receipt' => '\OpenAPI\Client\Model\ReceiptOptions',
        'lightning_amount_in_satoshi' => 'bool',
        'lightning_private_route_hints' => 'bool',
        'on_chain_with_ln_invoice_fallback' => 'bool',
        'redirect_automatically' => 'bool',
        'show_recommended_fee' => 'bool',
        'recommended_fee_block_target' => 'int',
        'default_lang' => 'string',
        'html_title' => 'string',
        'network_fee_mode' => '\OpenAPI\Client\Model\NetworkFeeMode',
        'pay_join_enabled' => 'bool',
        'auto_detect_language' => 'bool',
        'show_pay_in_wallet_button' => 'bool',
        'show_store_header' => 'bool',
        'celebrate_payment' => 'bool',
        'play_sound_on_payment' => 'bool',
        'lazy_payment_methods' => 'bool',
        'default_payment_method' => 'string',
        'payment_method_criteria' => '\OpenAPI\Client\Model\PaymentMethodCriteriaData[]',
        'id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'name' => null,
        'website' => 'url',
        'support_url' => 'uri',
        'logo_url' => 'uri',
        'css_url' => 'uri',
        'payment_sound_url' => 'uri',
        'brand_color' => null,
        'apply_brand_color_to_backend' => null,
        'default_currency' => null,
        'additional_tracked_rates' => null,
        'invoice_expiration' => null,
        'refund_bolt11_expiration' => null,
        'display_expiration_timer' => null,
        'monitoring_expiration' => null,
        'speed_policy' => null,
        'lightning_description_template' => null,
        'payment_tolerance' => 'double',
        'archived' => null,
        'anyone_can_create_invoice' => null,
        'receipt' => null,
        'lightning_amount_in_satoshi' => null,
        'lightning_private_route_hints' => null,
        'on_chain_with_ln_invoice_fallback' => null,
        'redirect_automatically' => null,
        'show_recommended_fee' => null,
        'recommended_fee_block_target' => 'int32',
        'default_lang' => null,
        'html_title' => null,
        'network_fee_mode' => null,
        'pay_join_enabled' => null,
        'auto_detect_language' => null,
        'show_pay_in_wallet_button' => null,
        'show_store_header' => null,
        'celebrate_payment' => null,
        'play_sound_on_payment' => null,
        'lazy_payment_methods' => null,
        'default_payment_method' => null,
        'payment_method_criteria' => null,
        'id' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'name' => false,
        'website' => true,
        'support_url' => true,
        'logo_url' => true,
        'css_url' => true,
        'payment_sound_url' => true,
        'brand_color' => true,
        'apply_brand_color_to_backend' => false,
        'default_currency' => false,
        'additional_tracked_rates' => false,
        'invoice_expiration' => false,
        'refund_bolt11_expiration' => false,
        'display_expiration_timer' => false,
        'monitoring_expiration' => false,
        'speed_policy' => false,
        'lightning_description_template' => true,
        'payment_tolerance' => false,
        'archived' => false,
        'anyone_can_create_invoice' => false,
        'receipt' => true,
        'lightning_amount_in_satoshi' => false,
        'lightning_private_route_hints' => false,
        'on_chain_with_ln_invoice_fallback' => false,
        'redirect_automatically' => false,
        'show_recommended_fee' => false,
        'recommended_fee_block_target' => false,
        'default_lang' => false,
        'html_title' => true,
        'network_fee_mode' => false,
        'pay_join_enabled' => false,
        'auto_detect_language' => false,
        'show_pay_in_wallet_button' => false,
        'show_store_header' => false,
        'celebrate_payment' => false,
        'play_sound_on_payment' => false,
        'lazy_payment_methods' => false,
        'default_payment_method' => false,
        'payment_method_criteria' => true,
        'id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'website' => 'website',
        'support_url' => 'supportUrl',
        'logo_url' => 'logoUrl',
        'css_url' => 'cssUrl',
        'payment_sound_url' => 'paymentSoundUrl',
        'brand_color' => 'brandColor',
        'apply_brand_color_to_backend' => 'applyBrandColorToBackend',
        'default_currency' => 'defaultCurrency',
        'additional_tracked_rates' => 'additionalTrackedRates',
        'invoice_expiration' => 'invoiceExpiration',
        'refund_bolt11_expiration' => 'refundBOLT11Expiration',
        'display_expiration_timer' => 'displayExpirationTimer',
        'monitoring_expiration' => 'monitoringExpiration',
        'speed_policy' => 'speedPolicy',
        'lightning_description_template' => 'lightningDescriptionTemplate',
        'payment_tolerance' => 'paymentTolerance',
        'archived' => 'archived',
        'anyone_can_create_invoice' => 'anyoneCanCreateInvoice',
        'receipt' => 'receipt',
        'lightning_amount_in_satoshi' => 'lightningAmountInSatoshi',
        'lightning_private_route_hints' => 'lightningPrivateRouteHints',
        'on_chain_with_ln_invoice_fallback' => 'onChainWithLnInvoiceFallback',
        'redirect_automatically' => 'redirectAutomatically',
        'show_recommended_fee' => 'showRecommendedFee',
        'recommended_fee_block_target' => 'recommendedFeeBlockTarget',
        'default_lang' => 'defaultLang',
        'html_title' => 'htmlTitle',
        'network_fee_mode' => 'networkFeeMode',
        'pay_join_enabled' => 'payJoinEnabled',
        'auto_detect_language' => 'autoDetectLanguage',
        'show_pay_in_wallet_button' => 'showPayInWalletButton',
        'show_store_header' => 'showStoreHeader',
        'celebrate_payment' => 'celebratePayment',
        'play_sound_on_payment' => 'playSoundOnPayment',
        'lazy_payment_methods' => 'lazyPaymentMethods',
        'default_payment_method' => 'defaultPaymentMethod',
        'payment_method_criteria' => 'paymentMethodCriteria',
        'id' => 'id'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'website' => 'setWebsite',
        'support_url' => 'setSupportUrl',
        'logo_url' => 'setLogoUrl',
        'css_url' => 'setCssUrl',
        'payment_sound_url' => 'setPaymentSoundUrl',
        'brand_color' => 'setBrandColor',
        'apply_brand_color_to_backend' => 'setApplyBrandColorToBackend',
        'default_currency' => 'setDefaultCurrency',
        'additional_tracked_rates' => 'setAdditionalTrackedRates',
        'invoice_expiration' => 'setInvoiceExpiration',
        'refund_bolt11_expiration' => 'setRefundBolt11Expiration',
        'display_expiration_timer' => 'setDisplayExpirationTimer',
        'monitoring_expiration' => 'setMonitoringExpiration',
        'speed_policy' => 'setSpeedPolicy',
        'lightning_description_template' => 'setLightningDescriptionTemplate',
        'payment_tolerance' => 'setPaymentTolerance',
        'archived' => 'setArchived',
        'anyone_can_create_invoice' => 'setAnyoneCanCreateInvoice',
        'receipt' => 'setReceipt',
        'lightning_amount_in_satoshi' => 'setLightningAmountInSatoshi',
        'lightning_private_route_hints' => 'setLightningPrivateRouteHints',
        'on_chain_with_ln_invoice_fallback' => 'setOnChainWithLnInvoiceFallback',
        'redirect_automatically' => 'setRedirectAutomatically',
        'show_recommended_fee' => 'setShowRecommendedFee',
        'recommended_fee_block_target' => 'setRecommendedFeeBlockTarget',
        'default_lang' => 'setDefaultLang',
        'html_title' => 'setHtmlTitle',
        'network_fee_mode' => 'setNetworkFeeMode',
        'pay_join_enabled' => 'setPayJoinEnabled',
        'auto_detect_language' => 'setAutoDetectLanguage',
        'show_pay_in_wallet_button' => 'setShowPayInWalletButton',
        'show_store_header' => 'setShowStoreHeader',
        'celebrate_payment' => 'setCelebratePayment',
        'play_sound_on_payment' => 'setPlaySoundOnPayment',
        'lazy_payment_methods' => 'setLazyPaymentMethods',
        'default_payment_method' => 'setDefaultPaymentMethod',
        'payment_method_criteria' => 'setPaymentMethodCriteria',
        'id' => 'setId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'website' => 'getWebsite',
        'support_url' => 'getSupportUrl',
        'logo_url' => 'getLogoUrl',
        'css_url' => 'getCssUrl',
        'payment_sound_url' => 'getPaymentSoundUrl',
        'brand_color' => 'getBrandColor',
        'apply_brand_color_to_backend' => 'getApplyBrandColorToBackend',
        'default_currency' => 'getDefaultCurrency',
        'additional_tracked_rates' => 'getAdditionalTrackedRates',
        'invoice_expiration' => 'getInvoiceExpiration',
        'refund_bolt11_expiration' => 'getRefundBolt11Expiration',
        'display_expiration_timer' => 'getDisplayExpirationTimer',
        'monitoring_expiration' => 'getMonitoringExpiration',
        'speed_policy' => 'getSpeedPolicy',
        'lightning_description_template' => 'getLightningDescriptionTemplate',
        'payment_tolerance' => 'getPaymentTolerance',
        'archived' => 'getArchived',
        'anyone_can_create_invoice' => 'getAnyoneCanCreateInvoice',
        'receipt' => 'getReceipt',
        'lightning_amount_in_satoshi' => 'getLightningAmountInSatoshi',
        'lightning_private_route_hints' => 'getLightningPrivateRouteHints',
        'on_chain_with_ln_invoice_fallback' => 'getOnChainWithLnInvoiceFallback',
        'redirect_automatically' => 'getRedirectAutomatically',
        'show_recommended_fee' => 'getShowRecommendedFee',
        'recommended_fee_block_target' => 'getRecommendedFeeBlockTarget',
        'default_lang' => 'getDefaultLang',
        'html_title' => 'getHtmlTitle',
        'network_fee_mode' => 'getNetworkFeeMode',
        'pay_join_enabled' => 'getPayJoinEnabled',
        'auto_detect_language' => 'getAutoDetectLanguage',
        'show_pay_in_wallet_button' => 'getShowPayInWalletButton',
        'show_store_header' => 'getShowStoreHeader',
        'celebrate_payment' => 'getCelebratePayment',
        'play_sound_on_payment' => 'getPlaySoundOnPayment',
        'lazy_payment_methods' => 'getLazyPaymentMethods',
        'default_payment_method' => 'getDefaultPaymentMethod',
        'payment_method_criteria' => 'getPaymentMethodCriteria',
        'id' => 'getId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('website', $data ?? [], null);
        $this->setIfExists('support_url', $data ?? [], null);
        $this->setIfExists('logo_url', $data ?? [], null);
        $this->setIfExists('css_url', $data ?? [], null);
        $this->setIfExists('payment_sound_url', $data ?? [], null);
        $this->setIfExists('brand_color', $data ?? [], null);
        $this->setIfExists('apply_brand_color_to_backend', $data ?? [], false);
        $this->setIfExists('default_currency', $data ?? [], 'USD');
        $this->setIfExists('additional_tracked_rates', $data ?? [], null);
        $this->setIfExists('invoice_expiration', $data ?? [], null);
        $this->setIfExists('refund_bolt11_expiration', $data ?? [], null);
        $this->setIfExists('display_expiration_timer', $data ?? [], null);
        $this->setIfExists('monitoring_expiration', $data ?? [], null);
        $this->setIfExists('speed_policy', $data ?? [], null);
        $this->setIfExists('lightning_description_template', $data ?? [], null);
        $this->setIfExists('payment_tolerance', $data ?? [], 0.0);
        $this->setIfExists('archived', $data ?? [], false);
        $this->setIfExists('anyone_can_create_invoice', $data ?? [], false);
        $this->setIfExists('receipt', $data ?? [], null);
        $this->setIfExists('lightning_amount_in_satoshi', $data ?? [], false);
        $this->setIfExists('lightning_private_route_hints', $data ?? [], false);
        $this->setIfExists('on_chain_with_ln_invoice_fallback', $data ?? [], false);
        $this->setIfExists('redirect_automatically', $data ?? [], false);
        $this->setIfExists('show_recommended_fee', $data ?? [], true);
        $this->setIfExists('recommended_fee_block_target', $data ?? [], 1);
        $this->setIfExists('default_lang', $data ?? [], 'en');
        $this->setIfExists('html_title', $data ?? [], null);
        $this->setIfExists('network_fee_mode', $data ?? [], null);
        $this->setIfExists('pay_join_enabled', $data ?? [], false);
        $this->setIfExists('auto_detect_language', $data ?? [], false);
        $this->setIfExists('show_pay_in_wallet_button', $data ?? [], true);
        $this->setIfExists('show_store_header', $data ?? [], true);
        $this->setIfExists('celebrate_payment', $data ?? [], true);
        $this->setIfExists('play_sound_on_payment', $data ?? [], false);
        $this->setIfExists('lazy_payment_methods', $data ?? [], false);
        $this->setIfExists('default_payment_method', $data ?? [], null);
        $this->setIfExists('payment_method_criteria', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['payment_tolerance']) && ($this->container['payment_tolerance'] > 100.0)) {
            $invalidProperties[] = "invalid value for 'payment_tolerance', must be smaller than or equal to 100.0.";
        }

        if (!is_null($this->container['payment_tolerance']) && ($this->container['payment_tolerance'] < 0.0)) {
            $invalidProperties[] = "invalid value for 'payment_tolerance', must be bigger than or equal to 0.0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the store
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets website
     *
     * @return string|null
     */
    public function getWebsite()
    {
        return $this->container['website'];
    }

    /**
     * Sets website
     *
     * @param string|null $website The absolute url of the store
     *
     * @return self
     */
    public function setWebsite($website)
    {
        if (is_null($website)) {
            array_push($this->openAPINullablesSetToNull, 'website');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('website', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['website'] = $website;

        return $this;
    }

    /**
     * Gets support_url
     *
     * @return string|null
     */
    public function getSupportUrl()
    {
        return $this->container['support_url'];
    }

    /**
     * Sets support_url
     *
     * @param string|null $support_url The support URI of the store, can contain the placeholders `{OrderId}` and `{InvoiceId}`. Can be any valid URI, such as a website, email, and nostr.
     *
     * @return self
     */
    public function setSupportUrl($support_url)
    {
        if (is_null($support_url)) {
            array_push($this->openAPINullablesSetToNull, 'support_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('support_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['support_url'] = $support_url;

        return $this;
    }

    /**
     * Gets logo_url
     *
     * @return string|null
     */
    public function getLogoUrl()
    {
        return $this->container['logo_url'];
    }

    /**
     * Sets logo_url
     *
     * @param string|null $logo_url Absolute URL to a logo file or a reference to an uploaded file id with `fileid:ID`
     *
     * @return self
     */
    public function setLogoUrl($logo_url)
    {
        if (is_null($logo_url)) {
            array_push($this->openAPINullablesSetToNull, 'logo_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('logo_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['logo_url'] = $logo_url;

        return $this;
    }

    /**
     * Gets css_url
     *
     * @return string|null
     */
    public function getCssUrl()
    {
        return $this->container['css_url'];
    }

    /**
     * Sets css_url
     *
     * @param string|null $css_url Absolute URL to CSS file to customize the public/customer-facing pages of the store. (Invoice, Payment Request, Pull Payment, etc.) or a reference to an uploaded file id with `fileid:ID`
     *
     * @return self
     */
    public function setCssUrl($css_url)
    {
        if (is_null($css_url)) {
            array_push($this->openAPINullablesSetToNull, 'css_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('css_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['css_url'] = $css_url;

        return $this;
    }

    /**
     * Gets payment_sound_url
     *
     * @return string|null
     */
    public function getPaymentSoundUrl()
    {
        return $this->container['payment_sound_url'];
    }

    /**
     * Sets payment_sound_url
     *
     * @param string|null $payment_sound_url Absolute URL to a sound file or a reference to an uploaded file id with `fileid:ID`
     *
     * @return self
     */
    public function setPaymentSoundUrl($payment_sound_url)
    {
        if (is_null($payment_sound_url)) {
            array_push($this->openAPINullablesSetToNull, 'payment_sound_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_sound_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payment_sound_url'] = $payment_sound_url;

        return $this;
    }

    /**
     * Gets brand_color
     *
     * @return string|null
     */
    public function getBrandColor()
    {
        return $this->container['brand_color'];
    }

    /**
     * Sets brand_color
     *
     * @param string|null $brand_color The brand color of the store in HEX format
     *
     * @return self
     */
    public function setBrandColor($brand_color)
    {
        if (is_null($brand_color)) {
            array_push($this->openAPINullablesSetToNull, 'brand_color');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('brand_color', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['brand_color'] = $brand_color;

        return $this;
    }

    /**
     * Gets apply_brand_color_to_backend
     *
     * @return bool|null
     */
    public function getApplyBrandColorToBackend()
    {
        return $this->container['apply_brand_color_to_backend'];
    }

    /**
     * Sets apply_brand_color_to_backend
     *
     * @param bool|null $apply_brand_color_to_backend Apply the brand color to the store's backend as well
     *
     * @return self
     */
    public function setApplyBrandColorToBackend($apply_brand_color_to_backend)
    {
        if (is_null($apply_brand_color_to_backend)) {
            throw new \InvalidArgumentException('non-nullable apply_brand_color_to_backend cannot be null');
        }
        $this->container['apply_brand_color_to_backend'] = $apply_brand_color_to_backend;

        return $this;
    }

    /**
     * Gets default_currency
     *
     * @return string|null
     */
    public function getDefaultCurrency()
    {
        return $this->container['default_currency'];
    }

    /**
     * Sets default_currency
     *
     * @param string|null $default_currency The default currency of the store
     *
     * @return self
     */
    public function setDefaultCurrency($default_currency)
    {
        if (is_null($default_currency)) {
            throw new \InvalidArgumentException('non-nullable default_currency cannot be null');
        }
        $this->container['default_currency'] = $default_currency;

        return $this;
    }

    /**
     * Gets additional_tracked_rates
     *
     * @return string[]|null
     */
    public function getAdditionalTrackedRates()
    {
        return $this->container['additional_tracked_rates'];
    }

    /**
     * Sets additional_tracked_rates
     *
     * @param string[]|null $additional_tracked_rates Additional rates to track. The rates of those currencies, in addition to the default currency, will be recorded when a new invoice is created. The rates will then be accessible through reports.
     *
     * @return self
     */
    public function setAdditionalTrackedRates($additional_tracked_rates)
    {
        if (is_null($additional_tracked_rates)) {
            throw new \InvalidArgumentException('non-nullable additional_tracked_rates cannot be null');
        }
        $this->container['additional_tracked_rates'] = $additional_tracked_rates;

        return $this;
    }

    /**
     * Gets invoice_expiration
     *
     * @return mixed|null
     */
    public function getInvoiceExpiration()
    {
        return $this->container['invoice_expiration'];
    }

    /**
     * Sets invoice_expiration
     *
     * @param mixed|null $invoice_expiration The time after which an invoice is considered expired if not paid. The value will be rounded down to a minute.
     *
     * @return self
     */
    public function setInvoiceExpiration($invoice_expiration)
    {
        if (is_null($invoice_expiration)) {
            throw new \InvalidArgumentException('non-nullable invoice_expiration cannot be null');
        }
        $this->container['invoice_expiration'] = $invoice_expiration;

        return $this;
    }

    /**
     * Gets refund_bolt11_expiration
     *
     * @return mixed|null
     */
    public function getRefundBolt11Expiration()
    {
        return $this->container['refund_bolt11_expiration'];
    }

    /**
     * Sets refund_bolt11_expiration
     *
     * @param mixed|null $refund_bolt11_expiration The minimum expiry of BOLT11 invoices accepted for refunds by default. (in days)
     *
     * @return self
     */
    public function setRefundBolt11Expiration($refund_bolt11_expiration)
    {
        if (is_null($refund_bolt11_expiration)) {
            throw new \InvalidArgumentException('non-nullable refund_bolt11_expiration cannot be null');
        }
        $this->container['refund_bolt11_expiration'] = $refund_bolt11_expiration;

        return $this;
    }

    /**
     * Gets display_expiration_timer
     *
     * @return mixed|null
     */
    public function getDisplayExpirationTimer()
    {
        return $this->container['display_expiration_timer'];
    }

    /**
     * Sets display_expiration_timer
     *
     * @param mixed|null $display_expiration_timer The time left that will trigger the countdown timer on the checkout page to be shown. The value will be rounded down to a minute.
     *
     * @return self
     */
    public function setDisplayExpirationTimer($display_expiration_timer)
    {
        if (is_null($display_expiration_timer)) {
            throw new \InvalidArgumentException('non-nullable display_expiration_timer cannot be null');
        }
        $this->container['display_expiration_timer'] = $display_expiration_timer;

        return $this;
    }

    /**
     * Gets monitoring_expiration
     *
     * @return mixed|null
     */
    public function getMonitoringExpiration()
    {
        return $this->container['monitoring_expiration'];
    }

    /**
     * Sets monitoring_expiration
     *
     * @param mixed|null $monitoring_expiration The time after which an invoice which has been paid but not confirmed will be considered invalid. The value will be rounded down to a minute.
     *
     * @return self
     */
    public function setMonitoringExpiration($monitoring_expiration)
    {
        if (is_null($monitoring_expiration)) {
            throw new \InvalidArgumentException('non-nullable monitoring_expiration cannot be null');
        }
        $this->container['monitoring_expiration'] = $monitoring_expiration;

        return $this;
    }

    /**
     * Gets speed_policy
     *
     * @return \OpenAPI\Client\Model\SpeedPolicy|null
     */
    public function getSpeedPolicy()
    {
        return $this->container['speed_policy'];
    }

    /**
     * Sets speed_policy
     *
     * @param \OpenAPI\Client\Model\SpeedPolicy|null $speed_policy speed_policy
     *
     * @return self
     */
    public function setSpeedPolicy($speed_policy)
    {
        if (is_null($speed_policy)) {
            throw new \InvalidArgumentException('non-nullable speed_policy cannot be null');
        }
        $this->container['speed_policy'] = $speed_policy;

        return $this;
    }

    /**
     * Gets lightning_description_template
     *
     * @return string|null
     */
    public function getLightningDescriptionTemplate()
    {
        return $this->container['lightning_description_template'];
    }

    /**
     * Sets lightning_description_template
     *
     * @param string|null $lightning_description_template The BOLT11 description of the lightning invoice in the checkout. You can use placeholders '{StoreName}', '{ItemDescription}' and '{OrderId}'.
     *
     * @return self
     */
    public function setLightningDescriptionTemplate($lightning_description_template)
    {
        if (is_null($lightning_description_template)) {
            array_push($this->openAPINullablesSetToNull, 'lightning_description_template');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('lightning_description_template', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['lightning_description_template'] = $lightning_description_template;

        return $this;
    }

    /**
     * Gets payment_tolerance
     *
     * @return float|null
     */
    public function getPaymentTolerance()
    {
        return $this->container['payment_tolerance'];
    }

    /**
     * Sets payment_tolerance
     *
     * @param float|null $payment_tolerance Consider an invoice fully paid, even if the payment is missing 'x' % of the full amount.
     *
     * @return self
     */
    public function setPaymentTolerance($payment_tolerance)
    {
        if (is_null($payment_tolerance)) {
            throw new \InvalidArgumentException('non-nullable payment_tolerance cannot be null');
        }

        if (($payment_tolerance > 100.0)) {
            throw new \InvalidArgumentException('invalid value for $payment_tolerance when calling StoreData., must be smaller than or equal to 100.0.');
        }
        if (($payment_tolerance < 0.0)) {
            throw new \InvalidArgumentException('invalid value for $payment_tolerance when calling StoreData., must be bigger than or equal to 0.0.');
        }

        $this->container['payment_tolerance'] = $payment_tolerance;

        return $this;
    }

    /**
     * Gets archived
     *
     * @return bool|null
     */
    public function getArchived()
    {
        return $this->container['archived'];
    }

    /**
     * Sets archived
     *
     * @param bool|null $archived If true, the store does not appear in the stores list by default.
     *
     * @return self
     */
    public function setArchived($archived)
    {
        if (is_null($archived)) {
            throw new \InvalidArgumentException('non-nullable archived cannot be null');
        }
        $this->container['archived'] = $archived;

        return $this;
    }

    /**
     * Gets anyone_can_create_invoice
     *
     * @return bool|null
     */
    public function getAnyoneCanCreateInvoice()
    {
        return $this->container['anyone_can_create_invoice'];
    }

    /**
     * Sets anyone_can_create_invoice
     *
     * @param bool|null $anyone_can_create_invoice If true, then no authentication is needed to create invoices on this store.
     *
     * @return self
     */
    public function setAnyoneCanCreateInvoice($anyone_can_create_invoice)
    {
        if (is_null($anyone_can_create_invoice)) {
            throw new \InvalidArgumentException('non-nullable anyone_can_create_invoice cannot be null');
        }
        $this->container['anyone_can_create_invoice'] = $anyone_can_create_invoice;

        return $this;
    }

    /**
     * Gets receipt
     *
     * @return \OpenAPI\Client\Model\ReceiptOptions|null
     */
    public function getReceipt()
    {
        return $this->container['receipt'];
    }

    /**
     * Sets receipt
     *
     * @param \OpenAPI\Client\Model\ReceiptOptions|null $receipt Additional settings to customize the public receipt
     *
     * @return self
     */
    public function setReceipt($receipt)
    {
        if (is_null($receipt)) {
            array_push($this->openAPINullablesSetToNull, 'receipt');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('receipt', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['receipt'] = $receipt;

        return $this;
    }

    /**
     * Gets lightning_amount_in_satoshi
     *
     * @return bool|null
     */
    public function getLightningAmountInSatoshi()
    {
        return $this->container['lightning_amount_in_satoshi'];
    }

    /**
     * Sets lightning_amount_in_satoshi
     *
     * @param bool|null $lightning_amount_in_satoshi If true, lightning payment methods show amount in satoshi in the checkout page.
     *
     * @return self
     */
    public function setLightningAmountInSatoshi($lightning_amount_in_satoshi)
    {
        if (is_null($lightning_amount_in_satoshi)) {
            throw new \InvalidArgumentException('non-nullable lightning_amount_in_satoshi cannot be null');
        }
        $this->container['lightning_amount_in_satoshi'] = $lightning_amount_in_satoshi;

        return $this;
    }

    /**
     * Gets lightning_private_route_hints
     *
     * @return bool|null
     */
    public function getLightningPrivateRouteHints()
    {
        return $this->container['lightning_private_route_hints'];
    }

    /**
     * Sets lightning_private_route_hints
     *
     * @param bool|null $lightning_private_route_hints Should private route hints be included in the lightning payment of the checkout page.
     *
     * @return self
     */
    public function setLightningPrivateRouteHints($lightning_private_route_hints)
    {
        if (is_null($lightning_private_route_hints)) {
            throw new \InvalidArgumentException('non-nullable lightning_private_route_hints cannot be null');
        }
        $this->container['lightning_private_route_hints'] = $lightning_private_route_hints;

        return $this;
    }

    /**
     * Gets on_chain_with_ln_invoice_fallback
     *
     * @return bool|null
     */
    public function getOnChainWithLnInvoiceFallback()
    {
        return $this->container['on_chain_with_ln_invoice_fallback'];
    }

    /**
     * Sets on_chain_with_ln_invoice_fallback
     *
     * @param bool|null $on_chain_with_ln_invoice_fallback Unify on-chain and lightning payment URL.
     *
     * @return self
     */
    public function setOnChainWithLnInvoiceFallback($on_chain_with_ln_invoice_fallback)
    {
        if (is_null($on_chain_with_ln_invoice_fallback)) {
            throw new \InvalidArgumentException('non-nullable on_chain_with_ln_invoice_fallback cannot be null');
        }
        $this->container['on_chain_with_ln_invoice_fallback'] = $on_chain_with_ln_invoice_fallback;

        return $this;
    }

    /**
     * Gets redirect_automatically
     *
     * @return bool|null
     */
    public function getRedirectAutomatically()
    {
        return $this->container['redirect_automatically'];
    }

    /**
     * Sets redirect_automatically
     *
     * @param bool|null $redirect_automatically After successfull payment, should the checkout page redirect the user automatically to the redirect URL of the invoice?
     *
     * @return self
     */
    public function setRedirectAutomatically($redirect_automatically)
    {
        if (is_null($redirect_automatically)) {
            throw new \InvalidArgumentException('non-nullable redirect_automatically cannot be null');
        }
        $this->container['redirect_automatically'] = $redirect_automatically;

        return $this;
    }

    /**
     * Gets show_recommended_fee
     *
     * @return bool|null
     */
    public function getShowRecommendedFee()
    {
        return $this->container['show_recommended_fee'];
    }

    /**
     * Sets show_recommended_fee
     *
     * @param bool|null $show_recommended_fee show_recommended_fee
     *
     * @return self
     */
    public function setShowRecommendedFee($show_recommended_fee)
    {
        if (is_null($show_recommended_fee)) {
            throw new \InvalidArgumentException('non-nullable show_recommended_fee cannot be null');
        }
        $this->container['show_recommended_fee'] = $show_recommended_fee;

        return $this;
    }

    /**
     * Gets recommended_fee_block_target
     *
     * @return int|null
     */
    public function getRecommendedFeeBlockTarget()
    {
        return $this->container['recommended_fee_block_target'];
    }

    /**
     * Sets recommended_fee_block_target
     *
     * @param int|null $recommended_fee_block_target The fee rate recommendation in the checkout page for the on-chain payment to be confirmed after 'x' blocks.
     *
     * @return self
     */
    public function setRecommendedFeeBlockTarget($recommended_fee_block_target)
    {
        if (is_null($recommended_fee_block_target)) {
            throw new \InvalidArgumentException('non-nullable recommended_fee_block_target cannot be null');
        }
        $this->container['recommended_fee_block_target'] = $recommended_fee_block_target;

        return $this;
    }

    /**
     * Gets default_lang
     *
     * @return string|null
     */
    public function getDefaultLang()
    {
        return $this->container['default_lang'];
    }

    /**
     * Sets default_lang
     *
     * @param string|null $default_lang The default language to use in the checkout page. (The different translations available are listed [here](https://github.com/btcpayserver/btcpayserver/tree/master/BTCPayServer/wwwroot/locales)
     *
     * @return self
     */
    public function setDefaultLang($default_lang)
    {
        if (is_null($default_lang)) {
            throw new \InvalidArgumentException('non-nullable default_lang cannot be null');
        }
        $this->container['default_lang'] = $default_lang;

        return $this;
    }

    /**
     * Gets html_title
     *
     * @return string|null
     */
    public function getHtmlTitle()
    {
        return $this->container['html_title'];
    }

    /**
     * Sets html_title
     *
     * @param string|null $html_title The HTML title of the checkout page (when you over the tab in your browser)
     *
     * @return self
     */
    public function setHtmlTitle($html_title)
    {
        if (is_null($html_title)) {
            array_push($this->openAPINullablesSetToNull, 'html_title');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('html_title', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['html_title'] = $html_title;

        return $this;
    }

    /**
     * Gets network_fee_mode
     *
     * @return \OpenAPI\Client\Model\NetworkFeeMode|null
     */
    public function getNetworkFeeMode()
    {
        return $this->container['network_fee_mode'];
    }

    /**
     * Sets network_fee_mode
     *
     * @param \OpenAPI\Client\Model\NetworkFeeMode|null $network_fee_mode network_fee_mode
     *
     * @return self
     */
    public function setNetworkFeeMode($network_fee_mode)
    {
        if (is_null($network_fee_mode)) {
            throw new \InvalidArgumentException('non-nullable network_fee_mode cannot be null');
        }
        $this->container['network_fee_mode'] = $network_fee_mode;

        return $this;
    }

    /**
     * Gets pay_join_enabled
     *
     * @return bool|null
     */
    public function getPayJoinEnabled()
    {
        return $this->container['pay_join_enabled'];
    }

    /**
     * Sets pay_join_enabled
     *
     * @param bool|null $pay_join_enabled If true, payjoin will be proposed in the checkout page if possible. ([More information](https://docs.btcpayserver.org/Payjoin/))
     *
     * @return self
     */
    public function setPayJoinEnabled($pay_join_enabled)
    {
        if (is_null($pay_join_enabled)) {
            throw new \InvalidArgumentException('non-nullable pay_join_enabled cannot be null');
        }
        $this->container['pay_join_enabled'] = $pay_join_enabled;

        return $this;
    }

    /**
     * Gets auto_detect_language
     *
     * @return bool|null
     */
    public function getAutoDetectLanguage()
    {
        return $this->container['auto_detect_language'];
    }

    /**
     * Sets auto_detect_language
     *
     * @param bool|null $auto_detect_language If true, the language on the checkout page will adapt to the language defined by the user's browser settings
     *
     * @return self
     */
    public function setAutoDetectLanguage($auto_detect_language)
    {
        if (is_null($auto_detect_language)) {
            throw new \InvalidArgumentException('non-nullable auto_detect_language cannot be null');
        }
        $this->container['auto_detect_language'] = $auto_detect_language;

        return $this;
    }

    /**
     * Gets show_pay_in_wallet_button
     *
     * @return bool|null
     */
    public function getShowPayInWalletButton()
    {
        return $this->container['show_pay_in_wallet_button'];
    }

    /**
     * Sets show_pay_in_wallet_button
     *
     * @param bool|null $show_pay_in_wallet_button If true, the \"Pay in wallet\" button will be shown on the checkout page (Checkout V2)
     *
     * @return self
     */
    public function setShowPayInWalletButton($show_pay_in_wallet_button)
    {
        if (is_null($show_pay_in_wallet_button)) {
            throw new \InvalidArgumentException('non-nullable show_pay_in_wallet_button cannot be null');
        }
        $this->container['show_pay_in_wallet_button'] = $show_pay_in_wallet_button;

        return $this;
    }

    /**
     * Gets show_store_header
     *
     * @return bool|null
     */
    public function getShowStoreHeader()
    {
        return $this->container['show_store_header'];
    }

    /**
     * Sets show_store_header
     *
     * @param bool|null $show_store_header If true, the store header will be shown on the checkout page (Checkout V2)
     *
     * @return self
     */
    public function setShowStoreHeader($show_store_header)
    {
        if (is_null($show_store_header)) {
            throw new \InvalidArgumentException('non-nullable show_store_header cannot be null');
        }
        $this->container['show_store_header'] = $show_store_header;

        return $this;
    }

    /**
     * Gets celebrate_payment
     *
     * @return bool|null
     */
    public function getCelebratePayment()
    {
        return $this->container['celebrate_payment'];
    }

    /**
     * Sets celebrate_payment
     *
     * @param bool|null $celebrate_payment If true, payments on the checkout page will be celebrated with confetti (Checkout V2)
     *
     * @return self
     */
    public function setCelebratePayment($celebrate_payment)
    {
        if (is_null($celebrate_payment)) {
            throw new \InvalidArgumentException('non-nullable celebrate_payment cannot be null');
        }
        $this->container['celebrate_payment'] = $celebrate_payment;

        return $this;
    }

    /**
     * Gets play_sound_on_payment
     *
     * @return bool|null
     */
    public function getPlaySoundOnPayment()
    {
        return $this->container['play_sound_on_payment'];
    }

    /**
     * Sets play_sound_on_payment
     *
     * @param bool|null $play_sound_on_payment If true, sounds on the checkout page will be enabled (Checkout V2)
     *
     * @return self
     */
    public function setPlaySoundOnPayment($play_sound_on_payment)
    {
        if (is_null($play_sound_on_payment)) {
            throw new \InvalidArgumentException('non-nullable play_sound_on_payment cannot be null');
        }
        $this->container['play_sound_on_payment'] = $play_sound_on_payment;

        return $this;
    }

    /**
     * Gets lazy_payment_methods
     *
     * @return bool|null
     */
    public function getLazyPaymentMethods()
    {
        return $this->container['lazy_payment_methods'];
    }

    /**
     * Sets lazy_payment_methods
     *
     * @param bool|null $lazy_payment_methods If true, payment methods are enabled individually upon user interaction in the invoice
     *
     * @return self
     */
    public function setLazyPaymentMethods($lazy_payment_methods)
    {
        if (is_null($lazy_payment_methods)) {
            throw new \InvalidArgumentException('non-nullable lazy_payment_methods cannot be null');
        }
        $this->container['lazy_payment_methods'] = $lazy_payment_methods;

        return $this;
    }

    /**
     * Gets default_payment_method
     *
     * @return string|null
     */
    public function getDefaultPaymentMethod()
    {
        return $this->container['default_payment_method'];
    }

    /**
     * Sets default_payment_method
     *
     * @param string|null $default_payment_method Payment method IDs. Available payment method IDs for Bitcoin are:   - `\"BTC-CHAIN\"`: Onchain    -`\"BTC-LN\"`: Lightning    - `\"BTC-LNURL\"`: LNURL
     *
     * @return self
     */
    public function setDefaultPaymentMethod($default_payment_method)
    {
        if (is_null($default_payment_method)) {
            throw new \InvalidArgumentException('non-nullable default_payment_method cannot be null');
        }
        $this->container['default_payment_method'] = $default_payment_method;

        return $this;
    }

    /**
     * Gets payment_method_criteria
     *
     * @return \OpenAPI\Client\Model\PaymentMethodCriteriaData[]|null
     */
    public function getPaymentMethodCriteria()
    {
        return $this->container['payment_method_criteria'];
    }

    /**
     * Sets payment_method_criteria
     *
     * @param \OpenAPI\Client\Model\PaymentMethodCriteriaData[]|null $payment_method_criteria The criteria required to activate specific payment methods.
     *
     * @return self
     */
    public function setPaymentMethodCriteria($payment_method_criteria)
    {
        if (is_null($payment_method_criteria)) {
            array_push($this->openAPINullablesSetToNull, 'payment_method_criteria');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_method_criteria', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payment_method_criteria'] = $payment_method_criteria;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id The id of the store
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


