<?php
/**
 * LightningStoreApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * LightningStoreApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LightningStoreApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'storeLightningNodeApiConnectToNode' => [
            'application/json',
        ],
        'storeLightningNodeApiCreateInvoice' => [
            'application/json',
        ],
        'storeLightningNodeApiGetBalance' => [
            'application/json',
        ],
        'storeLightningNodeApiGetChannels' => [
            'application/json',
        ],
        'storeLightningNodeApiGetDepositAddress' => [
            'application/json',
        ],
        'storeLightningNodeApiGetHistogram' => [
            'application/json',
        ],
        'storeLightningNodeApiGetInfo' => [
            'application/json',
        ],
        'storeLightningNodeApiGetInvoice' => [
            'application/json',
        ],
        'storeLightningNodeApiGetInvoices' => [
            'application/json',
        ],
        'storeLightningNodeApiGetPayment' => [
            'application/json',
        ],
        'storeLightningNodeApiGetPayments' => [
            'application/json',
        ],
        'storeLightningNodeApiOpenChannel' => [
            'application/json',
        ],
        'storeLightningNodeApiPayInvoice' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation storeLightningNodeApiConnectToNode
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeLightningNodeApiConnectToNode($crypto_code, $store_id, $connect_to_node_request, string $contentType = self::contentTypes['storeLightningNodeApiConnectToNode'][0])
    {
        $this->storeLightningNodeApiConnectToNodeWithHttpInfo($crypto_code, $store_id, $connect_to_node_request, $contentType);
    }

    /**
     * Operation storeLightningNodeApiConnectToNodeWithHttpInfo
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiConnectToNodeWithHttpInfo($crypto_code, $store_id, $connect_to_node_request, string $contentType = self::contentTypes['storeLightningNodeApiConnectToNode'][0])
    {
        $request = $this->storeLightningNodeApiConnectToNodeRequest($crypto_code, $store_id, $connect_to_node_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiConnectToNodeAsync
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiConnectToNodeAsync($crypto_code, $store_id, $connect_to_node_request, string $contentType = self::contentTypes['storeLightningNodeApiConnectToNode'][0])
    {
        return $this->storeLightningNodeApiConnectToNodeAsyncWithHttpInfo($crypto_code, $store_id, $connect_to_node_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiConnectToNodeAsyncWithHttpInfo
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiConnectToNodeAsyncWithHttpInfo($crypto_code, $store_id, $connect_to_node_request, string $contentType = self::contentTypes['storeLightningNodeApiConnectToNode'][0])
    {
        $returnType = '';
        $request = $this->storeLightningNodeApiConnectToNodeRequest($crypto_code, $store_id, $connect_to_node_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiConnectToNode'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiConnectToNodeRequest($crypto_code, $store_id, $connect_to_node_request, string $contentType = self::contentTypes['storeLightningNodeApiConnectToNode'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiConnectToNode'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiConnectToNode'
            );
        }

        // verify the required parameter 'connect_to_node_request' is set
        if ($connect_to_node_request === null || (is_array($connect_to_node_request) && count($connect_to_node_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connect_to_node_request when calling storeLightningNodeApiConnectToNode'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/connect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connect_to_node_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connect_to_node_request));
            } else {
                $httpBody = $connect_to_node_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiCreateInvoice
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData|\OpenAPI\Client\Model\ProblemDetails
     */
    public function storeLightningNodeApiCreateInvoice($crypto_code, $store_id, $create_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiCreateInvoice'][0])
    {
        list($response) = $this->storeLightningNodeApiCreateInvoiceWithHttpInfo($crypto_code, $store_id, $create_lightning_invoice_request, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiCreateInvoiceWithHttpInfo
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiCreateInvoiceWithHttpInfo($crypto_code, $store_id, $create_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiCreateInvoice'][0])
    {
        $request = $this->storeLightningNodeApiCreateInvoiceRequest($crypto_code, $store_id, $create_lightning_invoice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiCreateInvoiceAsync
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiCreateInvoiceAsync($crypto_code, $store_id, $create_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiCreateInvoice'][0])
    {
        return $this->storeLightningNodeApiCreateInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $create_lightning_invoice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiCreateInvoiceAsyncWithHttpInfo
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiCreateInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $create_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiCreateInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData';
        $request = $this->storeLightningNodeApiCreateInvoiceRequest($crypto_code, $store_id, $create_lightning_invoice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiCreateInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiCreateInvoiceRequest($crypto_code, $store_id, $create_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiCreateInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiCreateInvoice'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiCreateInvoice'
            );
        }

        // verify the required parameter 'create_lightning_invoice_request' is set
        if ($create_lightning_invoice_request === null || (is_array($create_lightning_invoice_request) && count($create_lightning_invoice_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_lightning_invoice_request when calling storeLightningNodeApiCreateInvoice'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_lightning_invoice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_lightning_invoice_request));
            } else {
                $httpBody = $create_lightning_invoice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetBalance
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningNodeBalanceData
     */
    public function storeLightningNodeApiGetBalance($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetBalance'][0])
    {
        list($response) = $this->storeLightningNodeApiGetBalanceWithHttpInfo($crypto_code, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetBalanceWithHttpInfo
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningNodeBalanceData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetBalanceWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetBalance'][0])
    {
        $request = $this->storeLightningNodeApiGetBalanceRequest($crypto_code, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningNodeBalanceData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningNodeBalanceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningNodeBalanceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetBalanceAsync
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetBalanceAsync($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetBalance'][0])
    {
        return $this->storeLightningNodeApiGetBalanceAsyncWithHttpInfo($crypto_code, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetBalanceAsyncWithHttpInfo
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetBalanceAsyncWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetBalance'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningNodeBalanceData';
        $request = $this->storeLightningNodeApiGetBalanceRequest($crypto_code, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetBalance'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetBalanceRequest($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetBalance'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetBalance'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetBalance'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetChannels
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningChannelData[]
     */
    public function storeLightningNodeApiGetChannels($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetChannels'][0])
    {
        list($response) = $this->storeLightningNodeApiGetChannelsWithHttpInfo($crypto_code, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetChannelsWithHttpInfo
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningChannelData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetChannelsWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetChannels'][0])
    {
        $request = $this->storeLightningNodeApiGetChannelsRequest($crypto_code, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningChannelData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningChannelData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningChannelData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetChannelsAsync
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetChannelsAsync($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetChannels'][0])
    {
        return $this->storeLightningNodeApiGetChannelsAsyncWithHttpInfo($crypto_code, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetChannelsAsyncWithHttpInfo
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetChannelsAsyncWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetChannels'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningChannelData[]';
        $request = $this->storeLightningNodeApiGetChannelsRequest($crypto_code, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetChannels'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetChannelsRequest($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetChannels'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetChannels'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetChannels'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetDepositAddress
     *
     * Get deposit address
     *
     * @param  string $store_id The store ID (required)
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function storeLightningNodeApiGetDepositAddress($store_id, $crypto_code, string $contentType = self::contentTypes['storeLightningNodeApiGetDepositAddress'][0])
    {
        list($response) = $this->storeLightningNodeApiGetDepositAddressWithHttpInfo($store_id, $crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetDepositAddressWithHttpInfo
     *
     * Get deposit address
     *
     * @param  string $store_id The store ID (required)
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetDepositAddressWithHttpInfo($store_id, $crypto_code, string $contentType = self::contentTypes['storeLightningNodeApiGetDepositAddress'][0])
    {
        $request = $this->storeLightningNodeApiGetDepositAddressRequest($store_id, $crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetDepositAddressAsync
     *
     * Get deposit address
     *
     * @param  string $store_id The store ID (required)
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetDepositAddressAsync($store_id, $crypto_code, string $contentType = self::contentTypes['storeLightningNodeApiGetDepositAddress'][0])
    {
        return $this->storeLightningNodeApiGetDepositAddressAsyncWithHttpInfo($store_id, $crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetDepositAddressAsyncWithHttpInfo
     *
     * Get deposit address
     *
     * @param  string $store_id The store ID (required)
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetDepositAddressAsyncWithHttpInfo($store_id, $crypto_code, string $contentType = self::contentTypes['storeLightningNodeApiGetDepositAddress'][0])
    {
        $returnType = 'string';
        $request = $this->storeLightningNodeApiGetDepositAddressRequest($store_id, $crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetDepositAddress'
     *
     * @param  string $store_id The store ID (required)
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetDepositAddressRequest($store_id, $crypto_code, string $contentType = self::contentTypes['storeLightningNodeApiGetDepositAddress'][0])
    {

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetDepositAddress'
            );
        }

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetDepositAddress'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/address';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetHistogram
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistogramData
     */
    public function storeLightningNodeApiGetHistogram($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetHistogram'][0])
    {
        list($response) = $this->storeLightningNodeApiGetHistogramWithHttpInfo($crypto_code, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetHistogramWithHttpInfo
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistogramData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetHistogramWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetHistogram'][0])
    {
        $request = $this->storeLightningNodeApiGetHistogramRequest($crypto_code, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HistogramData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HistogramData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistogramData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetHistogramAsync
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetHistogramAsync($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetHistogram'][0])
    {
        return $this->storeLightningNodeApiGetHistogramAsyncWithHttpInfo($crypto_code, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetHistogramAsyncWithHttpInfo
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetHistogramAsyncWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetHistogram'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HistogramData';
        $request = $this->storeLightningNodeApiGetHistogramRequest($crypto_code, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetHistogram'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetHistogramRequest($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetHistogram'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetHistogram'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetHistogram'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/histogram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningNodeInformationData
     */
    public function storeLightningNodeApiGetInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetInfo'][0])
    {
        list($response) = $this->storeLightningNodeApiGetInfoWithHttpInfo($crypto_code, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetInfoWithHttpInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningNodeInformationData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetInfoWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetInfo'][0])
    {
        $request = $this->storeLightningNodeApiGetInfoRequest($crypto_code, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningNodeInformationData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningNodeInformationData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningNodeInformationData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetInfoAsync
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInfoAsync($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetInfo'][0])
    {
        return $this->storeLightningNodeApiGetInfoAsyncWithHttpInfo($crypto_code, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetInfoAsyncWithHttpInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInfoAsyncWithHttpInfo($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningNodeInformationData';
        $request = $this->storeLightningNodeApiGetInfoRequest($crypto_code, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetInfo'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetInfoRequest($crypto_code, $store_id, string $contentType = self::contentTypes['storeLightningNodeApiGetInfo'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetInfo'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetInfo'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetInvoice
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData
     */
    public function storeLightningNodeApiGetInvoice($crypto_code, $store_id, $id, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoice'][0])
    {
        list($response) = $this->storeLightningNodeApiGetInvoiceWithHttpInfo($crypto_code, $store_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetInvoiceWithHttpInfo
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetInvoiceWithHttpInfo($crypto_code, $store_id, $id, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoice'][0])
    {
        $request = $this->storeLightningNodeApiGetInvoiceRequest($crypto_code, $store_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetInvoiceAsync
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInvoiceAsync($crypto_code, $store_id, $id, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoice'][0])
    {
        return $this->storeLightningNodeApiGetInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetInvoiceAsyncWithHttpInfo
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $id, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData';
        $request = $this->storeLightningNodeApiGetInvoiceRequest($crypto_code, $store_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetInvoiceRequest($crypto_code, $store_id, $id, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetInvoice'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetInvoice'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling storeLightningNodeApiGetInvoice'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetInvoices
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails
     */
    public function storeLightningNodeApiGetInvoices($crypto_code, $store_id, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoices'][0])
    {
        list($response) = $this->storeLightningNodeApiGetInvoicesWithHttpInfo($crypto_code, $store_id, $pending_only, $offset_index, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetInvoicesWithHttpInfo
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetInvoicesWithHttpInfo($crypto_code, $store_id, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoices'][0])
    {
        $request = $this->storeLightningNodeApiGetInvoicesRequest($crypto_code, $store_id, $pending_only, $offset_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetInvoicesAsync
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInvoicesAsync($crypto_code, $store_id, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoices'][0])
    {
        return $this->storeLightningNodeApiGetInvoicesAsyncWithHttpInfo($crypto_code, $store_id, $pending_only, $offset_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetInvoicesAsyncWithHttpInfo
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetInvoicesAsyncWithHttpInfo($crypto_code, $store_id, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoices'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData[]';
        $request = $this->storeLightningNodeApiGetInvoicesRequest($crypto_code, $store_id, $pending_only, $offset_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetInvoices'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetInvoicesRequest($crypto_code, $store_id, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetInvoices'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetInvoices'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetInvoices'
            );
        }




        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending_only,
            'pendingOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset_index,
            'offsetIndex', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetPayment
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData
     */
    public function storeLightningNodeApiGetPayment($crypto_code, $store_id, $payment_hash, string $contentType = self::contentTypes['storeLightningNodeApiGetPayment'][0])
    {
        list($response) = $this->storeLightningNodeApiGetPaymentWithHttpInfo($crypto_code, $store_id, $payment_hash, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetPaymentWithHttpInfo
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetPaymentWithHttpInfo($crypto_code, $store_id, $payment_hash, string $contentType = self::contentTypes['storeLightningNodeApiGetPayment'][0])
    {
        $request = $this->storeLightningNodeApiGetPaymentRequest($crypto_code, $store_id, $payment_hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetPaymentAsync
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetPaymentAsync($crypto_code, $store_id, $payment_hash, string $contentType = self::contentTypes['storeLightningNodeApiGetPayment'][0])
    {
        return $this->storeLightningNodeApiGetPaymentAsyncWithHttpInfo($crypto_code, $store_id, $payment_hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetPaymentAsyncWithHttpInfo
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetPaymentAsyncWithHttpInfo($crypto_code, $store_id, $payment_hash, string $contentType = self::contentTypes['storeLightningNodeApiGetPayment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData';
        $request = $this->storeLightningNodeApiGetPaymentRequest($crypto_code, $store_id, $payment_hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetPayment'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetPaymentRequest($crypto_code, $store_id, $payment_hash, string $contentType = self::contentTypes['storeLightningNodeApiGetPayment'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetPayment'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetPayment'
            );
        }

        // verify the required parameter 'payment_hash' is set
        if ($payment_hash === null || (is_array($payment_hash) && count($payment_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_hash when calling storeLightningNodeApiGetPayment'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments/{paymentHash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentHash' . '}',
                ObjectSerializer::toPathValue($payment_hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiGetPayments
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails
     */
    public function storeLightningNodeApiGetPayments($crypto_code, $store_id, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetPayments'][0])
    {
        list($response) = $this->storeLightningNodeApiGetPaymentsWithHttpInfo($crypto_code, $store_id, $include_pending, $offset_index, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiGetPaymentsWithHttpInfo
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiGetPaymentsWithHttpInfo($crypto_code, $store_id, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetPayments'][0])
    {
        $request = $this->storeLightningNodeApiGetPaymentsRequest($crypto_code, $store_id, $include_pending, $offset_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiGetPaymentsAsync
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetPaymentsAsync($crypto_code, $store_id, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetPayments'][0])
    {
        return $this->storeLightningNodeApiGetPaymentsAsyncWithHttpInfo($crypto_code, $store_id, $include_pending, $offset_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiGetPaymentsAsyncWithHttpInfo
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiGetPaymentsAsyncWithHttpInfo($crypto_code, $store_id, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetPayments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData[]';
        $request = $this->storeLightningNodeApiGetPaymentsRequest($crypto_code, $store_id, $include_pending, $offset_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiGetPayments'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiGetPaymentsRequest($crypto_code, $store_id, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['storeLightningNodeApiGetPayments'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiGetPayments'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiGetPayments'
            );
        }




        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_pending,
            'includePending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset_index,
            'offsetIndex', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiOpenChannel
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeLightningNodeApiOpenChannel($crypto_code, $store_id, $open_lightning_channel_request, string $contentType = self::contentTypes['storeLightningNodeApiOpenChannel'][0])
    {
        $this->storeLightningNodeApiOpenChannelWithHttpInfo($crypto_code, $store_id, $open_lightning_channel_request, $contentType);
    }

    /**
     * Operation storeLightningNodeApiOpenChannelWithHttpInfo
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiOpenChannelWithHttpInfo($crypto_code, $store_id, $open_lightning_channel_request, string $contentType = self::contentTypes['storeLightningNodeApiOpenChannel'][0])
    {
        $request = $this->storeLightningNodeApiOpenChannelRequest($crypto_code, $store_id, $open_lightning_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiOpenChannelAsync
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiOpenChannelAsync($crypto_code, $store_id, $open_lightning_channel_request, string $contentType = self::contentTypes['storeLightningNodeApiOpenChannel'][0])
    {
        return $this->storeLightningNodeApiOpenChannelAsyncWithHttpInfo($crypto_code, $store_id, $open_lightning_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiOpenChannelAsyncWithHttpInfo
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiOpenChannelAsyncWithHttpInfo($crypto_code, $store_id, $open_lightning_channel_request, string $contentType = self::contentTypes['storeLightningNodeApiOpenChannel'][0])
    {
        $returnType = '';
        $request = $this->storeLightningNodeApiOpenChannelRequest($crypto_code, $store_id, $open_lightning_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiOpenChannel'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiOpenChannelRequest($crypto_code, $store_id, $open_lightning_channel_request, string $contentType = self::contentTypes['storeLightningNodeApiOpenChannel'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiOpenChannel'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiOpenChannel'
            );
        }

        // verify the required parameter 'open_lightning_channel_request' is set
        if ($open_lightning_channel_request === null || (is_array($open_lightning_channel_request) && count($open_lightning_channel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $open_lightning_channel_request when calling storeLightningNodeApiOpenChannel'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($open_lightning_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($open_lightning_channel_request));
            } else {
                $httpBody = $open_lightning_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeLightningNodeApiPayInvoice
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]|\OpenAPI\Client\Model\ProblemDetails
     */
    public function storeLightningNodeApiPayInvoice($crypto_code, $store_id, $pay_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiPayInvoice'][0])
    {
        list($response) = $this->storeLightningNodeApiPayInvoiceWithHttpInfo($crypto_code, $store_id, $pay_lightning_invoice_request, $contentType);
        return $response;
    }

    /**
     * Operation storeLightningNodeApiPayInvoiceWithHttpInfo
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeLightningNodeApiPayInvoiceWithHttpInfo($crypto_code, $store_id, $pay_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiPayInvoice'][0])
    {
        $request = $this->storeLightningNodeApiPayInvoiceRequest($crypto_code, $store_id, $pay_lightning_invoice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeLightningNodeApiPayInvoiceAsync
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiPayInvoiceAsync($crypto_code, $store_id, $pay_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiPayInvoice'][0])
    {
        return $this->storeLightningNodeApiPayInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $pay_lightning_invoice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeLightningNodeApiPayInvoiceAsyncWithHttpInfo
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeLightningNodeApiPayInvoiceAsyncWithHttpInfo($crypto_code, $store_id, $pay_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiPayInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData';
        $request = $this->storeLightningNodeApiPayInvoiceRequest($crypto_code, $store_id, $pay_lightning_invoice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeLightningNodeApiPayInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeLightningNodeApiPayInvoiceRequest($crypto_code, $store_id, $pay_lightning_invoice_request, string $contentType = self::contentTypes['storeLightningNodeApiPayInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling storeLightningNodeApiPayInvoice'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeLightningNodeApiPayInvoice'
            );
        }

        // verify the required parameter 'pay_lightning_invoice_request' is set
        if ($pay_lightning_invoice_request === null || (is_array($pay_lightning_invoice_request) && count($pay_lightning_invoice_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pay_lightning_invoice_request when calling storeLightningNodeApiPayInvoice'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/pay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pay_lightning_invoice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pay_lightning_invoice_request));
            } else {
                $httpBody = $pay_lightning_invoice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
