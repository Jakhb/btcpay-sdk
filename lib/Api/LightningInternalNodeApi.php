<?php
/**
 * LightningInternalNodeApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * LightningInternalNodeApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LightningInternalNodeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'internalLightningNodeApiConnectToNode' => [
            'application/json',
        ],
        'internalLightningNodeApiCreateInvoice' => [
            'application/json',
        ],
        'internalLightningNodeApiGetBalance' => [
            'application/json',
        ],
        'internalLightningNodeApiGetChannels' => [
            'application/json',
        ],
        'internalLightningNodeApiGetDepositAddress' => [
            'application/json',
        ],
        'internalLightningNodeApiGetHistogram' => [
            'application/json',
        ],
        'internalLightningNodeApiGetInfo' => [
            'application/json',
        ],
        'internalLightningNodeApiGetInvoice' => [
            'application/json',
        ],
        'internalLightningNodeApiGetInvoices' => [
            'application/json',
        ],
        'internalLightningNodeApiGetPayment' => [
            'application/json',
        ],
        'internalLightningNodeApiGetPayments' => [
            'application/json',
        ],
        'internalLightningNodeApiOpenChannel' => [
            'application/json',
        ],
        'internalLightningNodeApiPayInvoice' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation internalLightningNodeApiConnectToNode
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function internalLightningNodeApiConnectToNode($crypto_code, $connect_to_node_request, string $contentType = self::contentTypes['internalLightningNodeApiConnectToNode'][0])
    {
        $this->internalLightningNodeApiConnectToNodeWithHttpInfo($crypto_code, $connect_to_node_request, $contentType);
    }

    /**
     * Operation internalLightningNodeApiConnectToNodeWithHttpInfo
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiConnectToNodeWithHttpInfo($crypto_code, $connect_to_node_request, string $contentType = self::contentTypes['internalLightningNodeApiConnectToNode'][0])
    {
        $request = $this->internalLightningNodeApiConnectToNodeRequest($crypto_code, $connect_to_node_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiConnectToNodeAsync
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiConnectToNodeAsync($crypto_code, $connect_to_node_request, string $contentType = self::contentTypes['internalLightningNodeApiConnectToNode'][0])
    {
        return $this->internalLightningNodeApiConnectToNodeAsyncWithHttpInfo($crypto_code, $connect_to_node_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiConnectToNodeAsyncWithHttpInfo
     *
     * Connect to lightning node
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiConnectToNodeAsyncWithHttpInfo($crypto_code, $connect_to_node_request, string $contentType = self::contentTypes['internalLightningNodeApiConnectToNode'][0])
    {
        $returnType = '';
        $request = $this->internalLightningNodeApiConnectToNodeRequest($crypto_code, $connect_to_node_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiConnectToNode'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\ConnectToNodeRequest $connect_to_node_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiConnectToNode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiConnectToNodeRequest($crypto_code, $connect_to_node_request, string $contentType = self::contentTypes['internalLightningNodeApiConnectToNode'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiConnectToNode'
            );
        }

        // verify the required parameter 'connect_to_node_request' is set
        if ($connect_to_node_request === null || (is_array($connect_to_node_request) && count($connect_to_node_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connect_to_node_request when calling internalLightningNodeApiConnectToNode'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/connect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connect_to_node_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connect_to_node_request));
            } else {
                $httpBody = $connect_to_node_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiCreateInvoice
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData|\OpenAPI\Client\Model\ProblemDetails
     */
    public function internalLightningNodeApiCreateInvoice($crypto_code, $create_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiCreateInvoice'][0])
    {
        list($response) = $this->internalLightningNodeApiCreateInvoiceWithHttpInfo($crypto_code, $create_lightning_invoice_request, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiCreateInvoiceWithHttpInfo
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiCreateInvoiceWithHttpInfo($crypto_code, $create_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiCreateInvoice'][0])
    {
        $request = $this->internalLightningNodeApiCreateInvoiceRequest($crypto_code, $create_lightning_invoice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiCreateInvoiceAsync
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiCreateInvoiceAsync($crypto_code, $create_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiCreateInvoice'][0])
    {
        return $this->internalLightningNodeApiCreateInvoiceAsyncWithHttpInfo($crypto_code, $create_lightning_invoice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiCreateInvoiceAsyncWithHttpInfo
     *
     * Create lightning invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiCreateInvoiceAsyncWithHttpInfo($crypto_code, $create_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiCreateInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData';
        $request = $this->internalLightningNodeApiCreateInvoiceRequest($crypto_code, $create_lightning_invoice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiCreateInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\CreateLightningInvoiceRequest $create_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiCreateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiCreateInvoiceRequest($crypto_code, $create_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiCreateInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiCreateInvoice'
            );
        }

        // verify the required parameter 'create_lightning_invoice_request' is set
        if ($create_lightning_invoice_request === null || (is_array($create_lightning_invoice_request) && count($create_lightning_invoice_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_lightning_invoice_request when calling internalLightningNodeApiCreateInvoice'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_lightning_invoice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_lightning_invoice_request));
            } else {
                $httpBody = $create_lightning_invoice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetBalance
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningNodeBalanceData
     */
    public function internalLightningNodeApiGetBalance($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetBalance'][0])
    {
        list($response) = $this->internalLightningNodeApiGetBalanceWithHttpInfo($crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetBalanceWithHttpInfo
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningNodeBalanceData, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetBalanceWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetBalance'][0])
    {
        $request = $this->internalLightningNodeApiGetBalanceRequest($crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningNodeBalanceData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningNodeBalanceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningNodeBalanceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetBalanceAsync
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetBalanceAsync($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetBalance'][0])
    {
        return $this->internalLightningNodeApiGetBalanceAsyncWithHttpInfo($crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetBalanceAsyncWithHttpInfo
     *
     * Get node balance
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetBalanceAsyncWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetBalance'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningNodeBalanceData';
        $request = $this->internalLightningNodeApiGetBalanceRequest($crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetBalance'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetBalanceRequest($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetBalance'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetBalance'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetChannels
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningChannelData[]
     */
    public function internalLightningNodeApiGetChannels($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetChannels'][0])
    {
        list($response) = $this->internalLightningNodeApiGetChannelsWithHttpInfo($crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetChannelsWithHttpInfo
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningChannelData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetChannelsWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetChannels'][0])
    {
        $request = $this->internalLightningNodeApiGetChannelsRequest($crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningChannelData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningChannelData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningChannelData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetChannelsAsync
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetChannelsAsync($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetChannels'][0])
    {
        return $this->internalLightningNodeApiGetChannelsAsyncWithHttpInfo($crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetChannelsAsyncWithHttpInfo
     *
     * Get channels
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetChannelsAsyncWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetChannels'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningChannelData[]';
        $request = $this->internalLightningNodeApiGetChannelsRequest($crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetChannels'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetChannelsRequest($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetChannels'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetChannels'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetDepositAddress
     *
     * Get deposit address
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function internalLightningNodeApiGetDepositAddress($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetDepositAddress'][0])
    {
        list($response) = $this->internalLightningNodeApiGetDepositAddressWithHttpInfo($crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetDepositAddressWithHttpInfo
     *
     * Get deposit address
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetDepositAddressWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetDepositAddress'][0])
    {
        $request = $this->internalLightningNodeApiGetDepositAddressRequest($crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetDepositAddressAsync
     *
     * Get deposit address
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetDepositAddressAsync($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetDepositAddress'][0])
    {
        return $this->internalLightningNodeApiGetDepositAddressAsyncWithHttpInfo($crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetDepositAddressAsyncWithHttpInfo
     *
     * Get deposit address
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetDepositAddressAsyncWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetDepositAddress'][0])
    {
        $returnType = 'string';
        $request = $this->internalLightningNodeApiGetDepositAddressRequest($crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetDepositAddress'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetDepositAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetDepositAddressRequest($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetDepositAddress'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetDepositAddress'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/address';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetHistogram
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistogramData
     */
    public function internalLightningNodeApiGetHistogram($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetHistogram'][0])
    {
        list($response) = $this->internalLightningNodeApiGetHistogramWithHttpInfo($crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetHistogramWithHttpInfo
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistogramData, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetHistogramWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetHistogram'][0])
    {
        $request = $this->internalLightningNodeApiGetHistogramRequest($crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HistogramData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HistogramData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistogramData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetHistogramAsync
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetHistogramAsync($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetHistogram'][0])
    {
        return $this->internalLightningNodeApiGetHistogramAsyncWithHttpInfo($crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetHistogramAsyncWithHttpInfo
     *
     * Get node balance histogram
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetHistogramAsyncWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetHistogram'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HistogramData';
        $request = $this->internalLightningNodeApiGetHistogramRequest($crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetHistogram'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetHistogramRequest($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetHistogram'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetHistogram'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/histogram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningNodeInformationData
     */
    public function internalLightningNodeApiGetInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetInfo'][0])
    {
        list($response) = $this->internalLightningNodeApiGetInfoWithHttpInfo($crypto_code, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetInfoWithHttpInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningNodeInformationData, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetInfoWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetInfo'][0])
    {
        $request = $this->internalLightningNodeApiGetInfoRequest($crypto_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningNodeInformationData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningNodeInformationData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningNodeInformationData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetInfoAsync
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInfoAsync($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetInfo'][0])
    {
        return $this->internalLightningNodeApiGetInfoAsyncWithHttpInfo($crypto_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetInfoAsyncWithHttpInfo
     *
     * Get node information
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInfoAsyncWithHttpInfo($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningNodeInformationData';
        $request = $this->internalLightningNodeApiGetInfoRequest($crypto_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetInfo'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetInfoRequest($crypto_code, string $contentType = self::contentTypes['internalLightningNodeApiGetInfo'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetInfo'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetInvoice
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData
     */
    public function internalLightningNodeApiGetInvoice($crypto_code, $id, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoice'][0])
    {
        list($response) = $this->internalLightningNodeApiGetInvoiceWithHttpInfo($crypto_code, $id, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetInvoiceWithHttpInfo
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetInvoiceWithHttpInfo($crypto_code, $id, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoice'][0])
    {
        $request = $this->internalLightningNodeApiGetInvoiceRequest($crypto_code, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetInvoiceAsync
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInvoiceAsync($crypto_code, $id, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoice'][0])
    {
        return $this->internalLightningNodeApiGetInvoiceAsyncWithHttpInfo($crypto_code, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetInvoiceAsyncWithHttpInfo
     *
     * Get invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInvoiceAsyncWithHttpInfo($crypto_code, $id, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData';
        $request = $this->internalLightningNodeApiGetInvoiceRequest($crypto_code, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $id The id of the lightning invoice. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetInvoiceRequest($crypto_code, $id, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetInvoice'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling internalLightningNodeApiGetInvoice'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetInvoices
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningInvoiceData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails
     */
    public function internalLightningNodeApiGetInvoices($crypto_code, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoices'][0])
    {
        list($response) = $this->internalLightningNodeApiGetInvoicesWithHttpInfo($crypto_code, $pending_only, $offset_index, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetInvoicesWithHttpInfo
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningInvoiceData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetInvoicesWithHttpInfo($crypto_code, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoices'][0])
    {
        $request = $this->internalLightningNodeApiGetInvoicesRequest($crypto_code, $pending_only, $offset_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningInvoiceData[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningInvoiceData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningInvoiceData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetInvoicesAsync
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInvoicesAsync($crypto_code, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoices'][0])
    {
        return $this->internalLightningNodeApiGetInvoicesAsyncWithHttpInfo($crypto_code, $pending_only, $offset_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetInvoicesAsyncWithHttpInfo
     *
     * Get invoices
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetInvoicesAsyncWithHttpInfo($crypto_code, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoices'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningInvoiceData[]';
        $request = $this->internalLightningNodeApiGetInvoicesRequest($crypto_code, $pending_only, $offset_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetInvoices'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $pending_only Limit to pending invoices only (optional, default to false)
     * @param  float|null $offset_index The index of an invoice that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetInvoicesRequest($crypto_code, $pending_only = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetInvoices'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetInvoices'
            );
        }




        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending_only,
            'pendingOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset_index,
            'offsetIndex', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetPayment
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData
     */
    public function internalLightningNodeApiGetPayment($crypto_code, $payment_hash, string $contentType = self::contentTypes['internalLightningNodeApiGetPayment'][0])
    {
        list($response) = $this->internalLightningNodeApiGetPaymentWithHttpInfo($crypto_code, $payment_hash, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetPaymentWithHttpInfo
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetPaymentWithHttpInfo($crypto_code, $payment_hash, string $contentType = self::contentTypes['internalLightningNodeApiGetPayment'][0])
    {
        $request = $this->internalLightningNodeApiGetPaymentRequest($crypto_code, $payment_hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetPaymentAsync
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetPaymentAsync($crypto_code, $payment_hash, string $contentType = self::contentTypes['internalLightningNodeApiGetPayment'][0])
    {
        return $this->internalLightningNodeApiGetPaymentAsyncWithHttpInfo($crypto_code, $payment_hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetPaymentAsyncWithHttpInfo
     *
     * Get payment
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetPaymentAsyncWithHttpInfo($crypto_code, $payment_hash, string $contentType = self::contentTypes['internalLightningNodeApiGetPayment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData';
        $request = $this->internalLightningNodeApiGetPaymentRequest($crypto_code, $payment_hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetPayment'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  string $payment_hash The payment hash of the lightning payment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetPaymentRequest($crypto_code, $payment_hash, string $contentType = self::contentTypes['internalLightningNodeApiGetPayment'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetPayment'
            );
        }

        // verify the required parameter 'payment_hash' is set
        if ($payment_hash === null || (is_array($payment_hash) && count($payment_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_hash when calling internalLightningNodeApiGetPayment'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/payments/{paymentHash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }
        // path params
        if ($payment_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentHash' . '}',
                ObjectSerializer::toPathValue($payment_hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiGetPayments
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of a payment that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails
     */
    public function internalLightningNodeApiGetPayments($crypto_code, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetPayments'][0])
    {
        list($response) = $this->internalLightningNodeApiGetPaymentsWithHttpInfo($crypto_code, $include_pending, $offset_index, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiGetPaymentsWithHttpInfo
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of a payment that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData[]|\OpenAPI\Client\Model\ProblemDetails|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiGetPaymentsWithHttpInfo($crypto_code, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetPayments'][0])
    {
        $request = $this->internalLightningNodeApiGetPaymentsRequest($crypto_code, $include_pending, $offset_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiGetPaymentsAsync
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of a payment that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetPaymentsAsync($crypto_code, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetPayments'][0])
    {
        return $this->internalLightningNodeApiGetPaymentsAsyncWithHttpInfo($crypto_code, $include_pending, $offset_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiGetPaymentsAsyncWithHttpInfo
     *
     * Get payments
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of a payment that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiGetPaymentsAsyncWithHttpInfo($crypto_code, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetPayments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData[]';
        $request = $this->internalLightningNodeApiGetPaymentsRequest($crypto_code, $include_pending, $offset_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiGetPayments'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  bool|null $include_pending Also include pending payments (optional, default to false)
     * @param  float|null $offset_index The index of a payment that will be used as the start of the list (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiGetPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiGetPaymentsRequest($crypto_code, $include_pending = false, $offset_index = 0, string $contentType = self::contentTypes['internalLightningNodeApiGetPayments'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiGetPayments'
            );
        }




        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_pending,
            'includePending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset_index,
            'offsetIndex', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiOpenChannel
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function internalLightningNodeApiOpenChannel($crypto_code, $open_lightning_channel_request, string $contentType = self::contentTypes['internalLightningNodeApiOpenChannel'][0])
    {
        $this->internalLightningNodeApiOpenChannelWithHttpInfo($crypto_code, $open_lightning_channel_request, $contentType);
    }

    /**
     * Operation internalLightningNodeApiOpenChannelWithHttpInfo
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiOpenChannelWithHttpInfo($crypto_code, $open_lightning_channel_request, string $contentType = self::contentTypes['internalLightningNodeApiOpenChannel'][0])
    {
        $request = $this->internalLightningNodeApiOpenChannelRequest($crypto_code, $open_lightning_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiOpenChannelAsync
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiOpenChannelAsync($crypto_code, $open_lightning_channel_request, string $contentType = self::contentTypes['internalLightningNodeApiOpenChannel'][0])
    {
        return $this->internalLightningNodeApiOpenChannelAsyncWithHttpInfo($crypto_code, $open_lightning_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiOpenChannelAsyncWithHttpInfo
     *
     * Open channel
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiOpenChannelAsyncWithHttpInfo($crypto_code, $open_lightning_channel_request, string $contentType = self::contentTypes['internalLightningNodeApiOpenChannel'][0])
    {
        $returnType = '';
        $request = $this->internalLightningNodeApiOpenChannelRequest($crypto_code, $open_lightning_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiOpenChannel'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\OpenLightningChannelRequest $open_lightning_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiOpenChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiOpenChannelRequest($crypto_code, $open_lightning_channel_request, string $contentType = self::contentTypes['internalLightningNodeApiOpenChannel'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiOpenChannel'
            );
        }

        // verify the required parameter 'open_lightning_channel_request' is set
        if ($open_lightning_channel_request === null || (is_array($open_lightning_channel_request) && count($open_lightning_channel_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $open_lightning_channel_request when calling internalLightningNodeApiOpenChannel'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($open_lightning_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($open_lightning_channel_request));
            } else {
                $httpBody = $open_lightning_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalLightningNodeApiPayInvoice
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]|\OpenAPI\Client\Model\ProblemDetails
     */
    public function internalLightningNodeApiPayInvoice($crypto_code, $pay_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiPayInvoice'][0])
    {
        list($response) = $this->internalLightningNodeApiPayInvoiceWithHttpInfo($crypto_code, $pay_lightning_invoice_request, $contentType);
        return $response;
    }

    /**
     * Operation internalLightningNodeApiPayInvoiceWithHttpInfo
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\LightningPaymentData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalLightningNodeApiPayInvoiceWithHttpInfo($crypto_code, $pay_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiPayInvoice'][0])
    {
        $request = $this->internalLightningNodeApiPayInvoiceRequest($crypto_code, $pay_lightning_invoice_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LightningPaymentData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LightningPaymentData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation internalLightningNodeApiPayInvoiceAsync
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiPayInvoiceAsync($crypto_code, $pay_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiPayInvoice'][0])
    {
        return $this->internalLightningNodeApiPayInvoiceAsyncWithHttpInfo($crypto_code, $pay_lightning_invoice_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalLightningNodeApiPayInvoiceAsyncWithHttpInfo
     *
     * Pay Lightning Invoice
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalLightningNodeApiPayInvoiceAsyncWithHttpInfo($crypto_code, $pay_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiPayInvoice'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LightningPaymentData';
        $request = $this->internalLightningNodeApiPayInvoiceRequest($crypto_code, $pay_lightning_invoice_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalLightningNodeApiPayInvoice'
     *
     * @param  string $crypto_code The cryptoCode of the lightning-node to query (required)
     * @param  \OpenAPI\Client\Model\PayLightningInvoiceRequest $pay_lightning_invoice_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['internalLightningNodeApiPayInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalLightningNodeApiPayInvoiceRequest($crypto_code, $pay_lightning_invoice_request, string $contentType = self::contentTypes['internalLightningNodeApiPayInvoice'][0])
    {

        // verify the required parameter 'crypto_code' is set
        if ($crypto_code === null || (is_array($crypto_code) && count($crypto_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $crypto_code when calling internalLightningNodeApiPayInvoice'
            );
        }

        // verify the required parameter 'pay_lightning_invoice_request' is set
        if ($pay_lightning_invoice_request === null || (is_array($pay_lightning_invoice_request) && count($pay_lightning_invoice_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pay_lightning_invoice_request when calling internalLightningNodeApiPayInvoice'
            );
        }


        $resourcePath = '/api/v1/server/lightning/{cryptoCode}/invoices/pay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($crypto_code !== null) {
            $resourcePath = str_replace(
                '{' . 'cryptoCode' . '}',
                ObjectSerializer::toPathValue($crypto_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pay_lightning_invoice_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pay_lightning_invoice_request));
            } else {
                $httpBody = $pay_lightning_invoice_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
