<?php
/**
 * UsersApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * UsersApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UsersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'usersCreateUser' => [
            'application/json',
        ],
        'usersDeleteCurrentUser' => [
            'application/json',
        ],
        'usersDeleteCurrentUserProfilePicture' => [
            'application/json',
        ],
        'usersDeleteUser' => [
            'application/json',
        ],
        'usersGetCurrentUser' => [
            'application/json',
        ],
        'usersGetUser' => [
            'application/json',
        ],
        'usersGetUsers' => [
            'application/json',
        ],
        'usersToggleUserApproval' => [
            'application/json',
        ],
        'usersToggleUserLock' => [
            'application/json',
        ],
        'usersUpdateCurrentUser' => [
            'application/json',
        ],
        'usersUploadCurrentUserProfilePicture' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation usersCreateUser
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UsersCreateUserRequest $users_create_user_request users_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersCreateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]
     */
    public function usersCreateUser($users_create_user_request, string $contentType = self::contentTypes['usersCreateUser'][0])
    {
        list($response) = $this->usersCreateUserWithHttpInfo($users_create_user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersCreateUserWithHttpInfo
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UsersCreateUserRequest $users_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersCreateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserData|\OpenAPI\Client\Model\ValidationProblemDetailsInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersCreateUserWithHttpInfo($users_create_user_request, string $contentType = self::contentTypes['usersCreateUser'][0])
    {
        $request = $this->usersCreateUserRequest($users_create_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApplicationUserData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersCreateUserAsync
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UsersCreateUserRequest $users_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersCreateUserAsync($users_create_user_request, string $contentType = self::contentTypes['usersCreateUser'][0])
    {
        return $this->usersCreateUserAsyncWithHttpInfo($users_create_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersCreateUserAsyncWithHttpInfo
     *
     * Create user
     *
     * @param  \OpenAPI\Client\Model\UsersCreateUserRequest $users_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersCreateUserAsyncWithHttpInfo($users_create_user_request, string $contentType = self::contentTypes['usersCreateUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserData';
        $request = $this->usersCreateUserRequest($users_create_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersCreateUser'
     *
     * @param  \OpenAPI\Client\Model\UsersCreateUserRequest $users_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersCreateUserRequest($users_create_user_request, string $contentType = self::contentTypes['usersCreateUser'][0])
    {

        // verify the required parameter 'users_create_user_request' is set
        if ($users_create_user_request === null || (is_array($users_create_user_request) && count($users_create_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $users_create_user_request when calling usersCreateUser'
            );
        }


        $resourcePath = '/api/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($users_create_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($users_create_user_request));
            } else {
                $httpBody = $users_create_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersDeleteCurrentUser
     *
     * Deletes user profile
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersDeleteCurrentUser(string $contentType = self::contentTypes['usersDeleteCurrentUser'][0])
    {
        $this->usersDeleteCurrentUserWithHttpInfo($contentType);
    }

    /**
     * Operation usersDeleteCurrentUserWithHttpInfo
     *
     * Deletes user profile
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersDeleteCurrentUserWithHttpInfo(string $contentType = self::contentTypes['usersDeleteCurrentUser'][0])
    {
        $request = $this->usersDeleteCurrentUserRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersDeleteCurrentUserAsync
     *
     * Deletes user profile
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteCurrentUserAsync(string $contentType = self::contentTypes['usersDeleteCurrentUser'][0])
    {
        return $this->usersDeleteCurrentUserAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersDeleteCurrentUserAsyncWithHttpInfo
     *
     * Deletes user profile
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteCurrentUserAsyncWithHttpInfo(string $contentType = self::contentTypes['usersDeleteCurrentUser'][0])
    {
        $returnType = '';
        $request = $this->usersDeleteCurrentUserRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersDeleteCurrentUser'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersDeleteCurrentUserRequest(string $contentType = self::contentTypes['usersDeleteCurrentUser'][0])
    {


        $resourcePath = '/api/v1/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersDeleteCurrentUserProfilePicture
     *
     * Deletes user profile picture
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersDeleteCurrentUserProfilePicture(string $contentType = self::contentTypes['usersDeleteCurrentUserProfilePicture'][0])
    {
        $this->usersDeleteCurrentUserProfilePictureWithHttpInfo($contentType);
    }

    /**
     * Operation usersDeleteCurrentUserProfilePictureWithHttpInfo
     *
     * Deletes user profile picture
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersDeleteCurrentUserProfilePictureWithHttpInfo(string $contentType = self::contentTypes['usersDeleteCurrentUserProfilePicture'][0])
    {
        $request = $this->usersDeleteCurrentUserProfilePictureRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersDeleteCurrentUserProfilePictureAsync
     *
     * Deletes user profile picture
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteCurrentUserProfilePictureAsync(string $contentType = self::contentTypes['usersDeleteCurrentUserProfilePicture'][0])
    {
        return $this->usersDeleteCurrentUserProfilePictureAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersDeleteCurrentUserProfilePictureAsyncWithHttpInfo
     *
     * Deletes user profile picture
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteCurrentUserProfilePictureAsyncWithHttpInfo(string $contentType = self::contentTypes['usersDeleteCurrentUserProfilePicture'][0])
    {
        $returnType = '';
        $request = $this->usersDeleteCurrentUserProfilePictureRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersDeleteCurrentUserProfilePicture'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersDeleteCurrentUserProfilePictureRequest(string $contentType = self::contentTypes['usersDeleteCurrentUserProfilePicture'][0])
    {


        $resourcePath = '/api/v1/users/me/picture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersDeleteUser
     *
     * Delete user
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersDeleteUser($id_or_email, string $contentType = self::contentTypes['usersDeleteUser'][0])
    {
        $this->usersDeleteUserWithHttpInfo($id_or_email, $contentType);
    }

    /**
     * Operation usersDeleteUserWithHttpInfo
     *
     * Delete user
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersDeleteUserWithHttpInfo($id_or_email, string $contentType = self::contentTypes['usersDeleteUser'][0])
    {
        $request = $this->usersDeleteUserRequest($id_or_email, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersDeleteUserAsync
     *
     * Delete user
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteUserAsync($id_or_email, string $contentType = self::contentTypes['usersDeleteUser'][0])
    {
        return $this->usersDeleteUserAsyncWithHttpInfo($id_or_email, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersDeleteUserAsyncWithHttpInfo
     *
     * Delete user
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersDeleteUserAsyncWithHttpInfo($id_or_email, string $contentType = self::contentTypes['usersDeleteUser'][0])
    {
        $returnType = '';
        $request = $this->usersDeleteUserRequest($id_or_email, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersDeleteUser'
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersDeleteUserRequest($id_or_email, string $contentType = self::contentTypes['usersDeleteUser'][0])
    {

        // verify the required parameter 'id_or_email' is set
        if ($id_or_email === null || (is_array($id_or_email) && count($id_or_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_email when calling usersDeleteUser'
            );
        }


        $resourcePath = '/api/v1/users/{idOrEmail}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id_or_email !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrEmail' . '}',
                ObjectSerializer::toPathValue($id_or_email),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGetCurrentUser
     *
     * Get current user information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserData
     */
    public function usersGetCurrentUser(string $contentType = self::contentTypes['usersGetCurrentUser'][0])
    {
        list($response) = $this->usersGetCurrentUserWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation usersGetCurrentUserWithHttpInfo
     *
     * Get current user information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserData, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetCurrentUserWithHttpInfo(string $contentType = self::contentTypes['usersGetCurrentUser'][0])
    {
        $request = $this->usersGetCurrentUserRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApplicationUserData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersGetCurrentUserAsync
     *
     * Get current user information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetCurrentUserAsync(string $contentType = self::contentTypes['usersGetCurrentUser'][0])
    {
        return $this->usersGetCurrentUserAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetCurrentUserAsyncWithHttpInfo
     *
     * Get current user information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetCurrentUserAsyncWithHttpInfo(string $contentType = self::contentTypes['usersGetCurrentUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserData';
        $request = $this->usersGetCurrentUserRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGetCurrentUser'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGetCurrentUserRequest(string $contentType = self::contentTypes['usersGetCurrentUser'][0])
    {


        $resourcePath = '/api/v1/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGetUser
     *
     * Get user by ID or Email
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserData
     */
    public function usersGetUser($id_or_email, string $contentType = self::contentTypes['usersGetUser'][0])
    {
        list($response) = $this->usersGetUserWithHttpInfo($id_or_email, $contentType);
        return $response;
    }

    /**
     * Operation usersGetUserWithHttpInfo
     *
     * Get user by ID or Email
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserData, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetUserWithHttpInfo($id_or_email, string $contentType = self::contentTypes['usersGetUser'][0])
    {
        $request = $this->usersGetUserRequest($id_or_email, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApplicationUserData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersGetUserAsync
     *
     * Get user by ID or Email
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUserAsync($id_or_email, string $contentType = self::contentTypes['usersGetUser'][0])
    {
        return $this->usersGetUserAsyncWithHttpInfo($id_or_email, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetUserAsyncWithHttpInfo
     *
     * Get user by ID or Email
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUserAsyncWithHttpInfo($id_or_email, string $contentType = self::contentTypes['usersGetUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserData';
        $request = $this->usersGetUserRequest($id_or_email, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGetUser'
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGetUserRequest($id_or_email, string $contentType = self::contentTypes['usersGetUser'][0])
    {

        // verify the required parameter 'id_or_email' is set
        if ($id_or_email === null || (is_array($id_or_email) && count($id_or_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_email when calling usersGetUser'
            );
        }


        $resourcePath = '/api/v1/users/{idOrEmail}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id_or_email !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrEmail' . '}',
                ObjectSerializer::toPathValue($id_or_email),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGetUsers
     *
     * Get all users
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersGetUsers(string $contentType = self::contentTypes['usersGetUsers'][0])
    {
        $this->usersGetUsersWithHttpInfo($contentType);
    }

    /**
     * Operation usersGetUsersWithHttpInfo
     *
     * Get all users
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetUsersWithHttpInfo(string $contentType = self::contentTypes['usersGetUsers'][0])
    {
        $request = $this->usersGetUsersRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersGetUsersAsync
     *
     * Get all users
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUsersAsync(string $contentType = self::contentTypes['usersGetUsers'][0])
    {
        return $this->usersGetUsersAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetUsersAsyncWithHttpInfo
     *
     * Get all users
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUsersAsyncWithHttpInfo(string $contentType = self::contentTypes['usersGetUsers'][0])
    {
        $returnType = '';
        $request = $this->usersGetUsersRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGetUsers'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersGetUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersGetUsersRequest(string $contentType = self::contentTypes['usersGetUsers'][0])
    {


        $resourcePath = '/api/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersToggleUserApproval
     *
     * Toggle user approval
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\ApproveUserRequest|null $approve_user_request approve_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserApproval'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersToggleUserApproval($id_or_email, $approve_user_request = null, string $contentType = self::contentTypes['usersToggleUserApproval'][0])
    {
        $this->usersToggleUserApprovalWithHttpInfo($id_or_email, $approve_user_request, $contentType);
    }

    /**
     * Operation usersToggleUserApprovalWithHttpInfo
     *
     * Toggle user approval
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\ApproveUserRequest|null $approve_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserApproval'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersToggleUserApprovalWithHttpInfo($id_or_email, $approve_user_request = null, string $contentType = self::contentTypes['usersToggleUserApproval'][0])
    {
        $request = $this->usersToggleUserApprovalRequest($id_or_email, $approve_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersToggleUserApprovalAsync
     *
     * Toggle user approval
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\ApproveUserRequest|null $approve_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersToggleUserApprovalAsync($id_or_email, $approve_user_request = null, string $contentType = self::contentTypes['usersToggleUserApproval'][0])
    {
        return $this->usersToggleUserApprovalAsyncWithHttpInfo($id_or_email, $approve_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersToggleUserApprovalAsyncWithHttpInfo
     *
     * Toggle user approval
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\ApproveUserRequest|null $approve_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersToggleUserApprovalAsyncWithHttpInfo($id_or_email, $approve_user_request = null, string $contentType = self::contentTypes['usersToggleUserApproval'][0])
    {
        $returnType = '';
        $request = $this->usersToggleUserApprovalRequest($id_or_email, $approve_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersToggleUserApproval'
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\ApproveUserRequest|null $approve_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserApproval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersToggleUserApprovalRequest($id_or_email, $approve_user_request = null, string $contentType = self::contentTypes['usersToggleUserApproval'][0])
    {

        // verify the required parameter 'id_or_email' is set
        if ($id_or_email === null || (is_array($id_or_email) && count($id_or_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_email when calling usersToggleUserApproval'
            );
        }



        $resourcePath = '/api/v1/users/{idOrEmail}/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id_or_email !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrEmail' . '}',
                ObjectSerializer::toPathValue($id_or_email),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($approve_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($approve_user_request));
            } else {
                $httpBody = $approve_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersToggleUserLock
     *
     * Toggle user lock out
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\LockUserRequest|null $lock_user_request lock_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserLock'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersToggleUserLock($id_or_email, $lock_user_request = null, string $contentType = self::contentTypes['usersToggleUserLock'][0])
    {
        $this->usersToggleUserLockWithHttpInfo($id_or_email, $lock_user_request, $contentType);
    }

    /**
     * Operation usersToggleUserLockWithHttpInfo
     *
     * Toggle user lock out
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\LockUserRequest|null $lock_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserLock'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersToggleUserLockWithHttpInfo($id_or_email, $lock_user_request = null, string $contentType = self::contentTypes['usersToggleUserLock'][0])
    {
        $request = $this->usersToggleUserLockRequest($id_or_email, $lock_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersToggleUserLockAsync
     *
     * Toggle user lock out
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\LockUserRequest|null $lock_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserLock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersToggleUserLockAsync($id_or_email, $lock_user_request = null, string $contentType = self::contentTypes['usersToggleUserLock'][0])
    {
        return $this->usersToggleUserLockAsyncWithHttpInfo($id_or_email, $lock_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersToggleUserLockAsyncWithHttpInfo
     *
     * Toggle user lock out
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\LockUserRequest|null $lock_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserLock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersToggleUserLockAsyncWithHttpInfo($id_or_email, $lock_user_request = null, string $contentType = self::contentTypes['usersToggleUserLock'][0])
    {
        $returnType = '';
        $request = $this->usersToggleUserLockRequest($id_or_email, $lock_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersToggleUserLock'
     *
     * @param  string $id_or_email The user&#39;s id or email (required)
     * @param  \OpenAPI\Client\Model\LockUserRequest|null $lock_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersToggleUserLock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersToggleUserLockRequest($id_or_email, $lock_user_request = null, string $contentType = self::contentTypes['usersToggleUserLock'][0])
    {

        // verify the required parameter 'id_or_email' is set
        if ($id_or_email === null || (is_array($id_or_email) && count($id_or_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_or_email when calling usersToggleUserLock'
            );
        }



        $resourcePath = '/api/v1/users/{idOrEmail}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id_or_email !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrEmail' . '}',
                ObjectSerializer::toPathValue($id_or_email),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lock_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($lock_user_request));
            } else {
                $httpBody = $lock_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUpdateCurrentUser
     *
     * Update current user information
     *
     * @param  \OpenAPI\Client\Model\UsersUpdateCurrentUserRequest $users_update_current_user_request users_update_current_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUpdateCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserData
     */
    public function usersUpdateCurrentUser($users_update_current_user_request, string $contentType = self::contentTypes['usersUpdateCurrentUser'][0])
    {
        list($response) = $this->usersUpdateCurrentUserWithHttpInfo($users_update_current_user_request, $contentType);
        return $response;
    }

    /**
     * Operation usersUpdateCurrentUserWithHttpInfo
     *
     * Update current user information
     *
     * @param  \OpenAPI\Client\Model\UsersUpdateCurrentUserRequest $users_update_current_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUpdateCurrentUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserData, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUpdateCurrentUserWithHttpInfo($users_update_current_user_request, string $contentType = self::contentTypes['usersUpdateCurrentUser'][0])
    {
        $request = $this->usersUpdateCurrentUserRequest($users_update_current_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApplicationUserData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersUpdateCurrentUserAsync
     *
     * Update current user information
     *
     * @param  \OpenAPI\Client\Model\UsersUpdateCurrentUserRequest $users_update_current_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUpdateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateCurrentUserAsync($users_update_current_user_request, string $contentType = self::contentTypes['usersUpdateCurrentUser'][0])
    {
        return $this->usersUpdateCurrentUserAsyncWithHttpInfo($users_update_current_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUpdateCurrentUserAsyncWithHttpInfo
     *
     * Update current user information
     *
     * @param  \OpenAPI\Client\Model\UsersUpdateCurrentUserRequest $users_update_current_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUpdateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateCurrentUserAsyncWithHttpInfo($users_update_current_user_request, string $contentType = self::contentTypes['usersUpdateCurrentUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserData';
        $request = $this->usersUpdateCurrentUserRequest($users_update_current_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUpdateCurrentUser'
     *
     * @param  \OpenAPI\Client\Model\UsersUpdateCurrentUserRequest $users_update_current_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUpdateCurrentUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUpdateCurrentUserRequest($users_update_current_user_request, string $contentType = self::contentTypes['usersUpdateCurrentUser'][0])
    {

        // verify the required parameter 'users_update_current_user_request' is set
        if ($users_update_current_user_request === null || (is_array($users_update_current_user_request) && count($users_update_current_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $users_update_current_user_request when calling usersUpdateCurrentUser'
            );
        }


        $resourcePath = '/api/v1/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($users_update_current_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($users_update_current_user_request));
            } else {
                $httpBody = $users_update_current_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUploadCurrentUserProfilePicture
     *
     * Uploads a profile picture for the current user
     *
     * @param  \SplFileObject|null $file The profile picture (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUploadCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserData
     */
    public function usersUploadCurrentUserProfilePicture($file = null, string $contentType = self::contentTypes['usersUploadCurrentUserProfilePicture'][0])
    {
        list($response) = $this->usersUploadCurrentUserProfilePictureWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation usersUploadCurrentUserProfilePictureWithHttpInfo
     *
     * Uploads a profile picture for the current user
     *
     * @param  \SplFileObject|null $file The profile picture (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUploadCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserData, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUploadCurrentUserProfilePictureWithHttpInfo($file = null, string $contentType = self::contentTypes['usersUploadCurrentUserProfilePicture'][0])
    {
        $request = $this->usersUploadCurrentUserProfilePictureRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApplicationUserData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation usersUploadCurrentUserProfilePictureAsync
     *
     * Uploads a profile picture for the current user
     *
     * @param  \SplFileObject|null $file The profile picture (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUploadCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUploadCurrentUserProfilePictureAsync($file = null, string $contentType = self::contentTypes['usersUploadCurrentUserProfilePicture'][0])
    {
        return $this->usersUploadCurrentUserProfilePictureAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUploadCurrentUserProfilePictureAsyncWithHttpInfo
     *
     * Uploads a profile picture for the current user
     *
     * @param  \SplFileObject|null $file The profile picture (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUploadCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUploadCurrentUserProfilePictureAsyncWithHttpInfo($file = null, string $contentType = self::contentTypes['usersUploadCurrentUserProfilePicture'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserData';
        $request = $this->usersUploadCurrentUserProfilePictureRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUploadCurrentUserProfilePicture'
     *
     * @param  \SplFileObject|null $file The profile picture (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersUploadCurrentUserProfilePicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersUploadCurrentUserProfilePictureRequest($file = null, string $contentType = self::contentTypes['usersUploadCurrentUserProfilePicture'][0])
    {



        $resourcePath = '/api/v1/users/me/picture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
