<?php
/**
 * StoreWalletOnChainApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BTCPay Greenfield API
 *
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * StoreWalletOnChainApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StoreWalletOnChainApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'storeOnChainPaymentMethodsGenerateOnChainWallet' => [
            'application/json',
        ],
        'storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview' => [
            'application/json',
        ],
        'storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview' => [
            'application/json',
        ],
        'storeOnChainWalletsAddOrUpdateOnChainWalletLink' => [
            'application/json',
        ],
        'storeOnChainWalletsAddOrUpdateOnChainWalletObjects' => [
            'application/json',
        ],
        'storeOnChainWalletsCreateOnChainTransaction' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainFeeRate' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainWalletObject' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainWalletObjects' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainWalletReceiveAddress' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainWalletTransaction' => [
            'application/json',
        ],
        'storeOnChainWalletsGetOnChainWalletUTXOs' => [
            'application/json',
        ],
        'storeOnChainWalletsPatchOnChainWalletTransaction' => [
            'application/json',
        ],
        'storeOnChainWalletsRemoveOnChainWalletLink' => [
            'application/json',
        ],
        'storeOnChainWalletsRemoveOnChainWalletObject' => [
            'application/json',
        ],
        'storeOnChainWalletsShowOnChainWalletHistogram' => [
            'application/json',
        ],
        'storeOnChainWalletsShowOnChainWalletOverview' => [
            'application/json',
        ],
        'storeOnChainWalletsShowOnChainWalletTransactions' => [
            'application/json',
        ],
        'storeOnChainWalletsUnReserveOnChainWalletReceiveAddress' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation storeOnChainPaymentMethodsGenerateOnChainWallet
     *
     * Generate store on-chain wallet
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\GenerateOnChainWalletRequest $generate_on_chain_wallet_request generate_on_chain_wallet_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response|\OpenAPI\Client\Model\ValidationProblemDetailsInner[]
     */
    public function storeOnChainPaymentMethodsGenerateOnChainWallet($payment_method_id, $store_id, $generate_on_chain_wallet_request, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'][0])
    {
        list($response) = $this->storeOnChainPaymentMethodsGenerateOnChainWalletWithHttpInfo($payment_method_id, $store_id, $generate_on_chain_wallet_request, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainPaymentMethodsGenerateOnChainWalletWithHttpInfo
     *
     * Generate store on-chain wallet
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\GenerateOnChainWalletRequest $generate_on_chain_wallet_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response|\OpenAPI\Client\Model\ValidationProblemDetailsInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainPaymentMethodsGenerateOnChainWalletWithHttpInfo($payment_method_id, $store_id, $generate_on_chain_wallet_request, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'][0])
    {
        $request = $this->storeOnChainPaymentMethodsGenerateOnChainWalletRequest($payment_method_id, $store_id, $generate_on_chain_wallet_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidationProblemDetailsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainPaymentMethodsGenerateOnChainWalletAsync
     *
     * Generate store on-chain wallet
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\GenerateOnChainWalletRequest $generate_on_chain_wallet_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsGenerateOnChainWalletAsync($payment_method_id, $store_id, $generate_on_chain_wallet_request, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'][0])
    {
        return $this->storeOnChainPaymentMethodsGenerateOnChainWalletAsyncWithHttpInfo($payment_method_id, $store_id, $generate_on_chain_wallet_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainPaymentMethodsGenerateOnChainWalletAsyncWithHttpInfo
     *
     * Generate store on-chain wallet
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\GenerateOnChainWalletRequest $generate_on_chain_wallet_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsGenerateOnChainWalletAsyncWithHttpInfo($payment_method_id, $store_id, $generate_on_chain_wallet_request, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StoreOnChainPaymentMethodsGenerateOnChainWallet200Response';
        $request = $this->storeOnChainPaymentMethodsGenerateOnChainWalletRequest($payment_method_id, $store_id, $generate_on_chain_wallet_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainPaymentMethodsGenerateOnChainWallet'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\GenerateOnChainWalletRequest $generate_on_chain_wallet_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainPaymentMethodsGenerateOnChainWalletRequest($payment_method_id, $store_id, $generate_on_chain_wallet_request, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGenerateOnChainWallet'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainPaymentMethodsGenerateOnChainWallet'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainPaymentMethodsGenerateOnChainWallet'
            );
        }

        // verify the required parameter 'generate_on_chain_wallet_request' is set
        if ($generate_on_chain_wallet_request === null || (is_array($generate_on_chain_wallet_request) && count($generate_on_chain_wallet_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_on_chain_wallet_request when calling storeOnChainPaymentMethodsGenerateOnChainWallet'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_on_chain_wallet_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_on_chain_wallet_request));
            } else {
                $httpBody = $generate_on_chain_wallet_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview
     *
     * Preview store on-chain payment method addresses
     *
     * @param  string $store_id The store ID (required)
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData
     */
    public function storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview($store_id, $payment_method_id, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'][0])
    {
        list($response) = $this->storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewWithHttpInfo($store_id, $payment_method_id, $offset, $count, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewWithHttpInfo
     *
     * Preview store on-chain payment method addresses
     *
     * @param  string $store_id The store ID (required)
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewWithHttpInfo($store_id, $payment_method_id, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'][0])
    {
        $request = $this->storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewRequest($store_id, $payment_method_id, $offset, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewAsync
     *
     * Preview store on-chain payment method addresses
     *
     * @param  string $store_id The store ID (required)
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewAsync($store_id, $payment_method_id, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'][0])
    {
        return $this->storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewAsyncWithHttpInfo($store_id, $payment_method_id, $offset, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewAsyncWithHttpInfo
     *
     * Preview store on-chain payment method addresses
     *
     * @param  string $store_id The store ID (required)
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewAsyncWithHttpInfo($store_id, $payment_method_id, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData';
        $request = $this->storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewRequest($store_id, $payment_method_id, $offset, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'
     *
     * @param  string $store_id The store ID (required)
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainPaymentMethodsGetOnChainPaymentMethodPreviewRequest($store_id, $payment_method_id, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'][0])
    {

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'
            );
        }

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview'
            );
        }




        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview
     *
     * Preview proposed store on-chain payment method addresses
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\StoreOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest $store_on_chain_payment_methods_poston_chain_payment_method_preview_request store_on_chain_payment_methods_poston_chain_payment_method_preview_request (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData
     */
    public function storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'][0])
    {
        list($response) = $this->storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewWithHttpInfo($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset, $count, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewWithHttpInfo
     *
     * Preview proposed store on-chain payment method addresses
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\StoreOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest $store_on_chain_payment_methods_poston_chain_payment_method_preview_request (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewWithHttpInfo($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'][0])
    {
        $request = $this->storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewAsync
     *
     * Preview proposed store on-chain payment method addresses
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\StoreOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest $store_on_chain_payment_methods_poston_chain_payment_method_preview_request (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewAsync($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'][0])
    {
        return $this->storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewAsyncWithHttpInfo($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewAsyncWithHttpInfo
     *
     * Preview proposed store on-chain payment method addresses
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\StoreOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest $store_on_chain_payment_methods_poston_chain_payment_method_preview_request (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewAsyncWithHttpInfo($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainPaymentMethodPreviewResultData';
        $request = $this->storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\StoreOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest $store_on_chain_payment_methods_poston_chain_payment_method_preview_request (required)
     * @param  float|null $offset From which index to fetch the addresses (optional)
     * @param  float|null $count Number of addresses to preview (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreviewRequest($payment_method_id, $store_id, $store_on_chain_payment_methods_poston_chain_payment_method_preview_request, $offset = null, $count = null, string $contentType = self::contentTypes['storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'
            );
        }

        // verify the required parameter 'store_on_chain_payment_methods_poston_chain_payment_method_preview_request' is set
        if ($store_on_chain_payment_methods_poston_chain_payment_method_preview_request === null || (is_array($store_on_chain_payment_methods_poston_chain_payment_method_preview_request) && count($store_on_chain_payment_methods_poston_chain_payment_method_preview_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_on_chain_payment_methods_poston_chain_payment_method_preview_request when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview'
            );
        }




        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($store_on_chain_payment_methods_poston_chain_payment_method_preview_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($store_on_chain_payment_methods_poston_chain_payment_method_preview_request));
            } else {
                $httpBody = $store_on_chain_payment_methods_poston_chain_payment_method_preview_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletLink
     *
     * Add/Update store on-chain wallet object link
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  \OpenAPI\Client\Model\AddOnChainWalletObjectLinkRequest $add_on_chain_wallet_object_link_request add_on_chain_wallet_object_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletLink($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'][0])
    {
        $this->storeOnChainWalletsAddOrUpdateOnChainWalletLinkWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, $contentType);
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletLinkWithHttpInfo
     *
     * Add/Update store on-chain wallet object link
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  \OpenAPI\Client\Model\AddOnChainWalletObjectLinkRequest $add_on_chain_wallet_object_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletLinkWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'][0])
    {
        $request = $this->storeOnChainWalletsAddOrUpdateOnChainWalletLinkRequest($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletLinkAsync
     *
     * Add/Update store on-chain wallet object link
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  \OpenAPI\Client\Model\AddOnChainWalletObjectLinkRequest $add_on_chain_wallet_object_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletLinkAsync($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'][0])
    {
        return $this->storeOnChainWalletsAddOrUpdateOnChainWalletLinkAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletLinkAsyncWithHttpInfo
     *
     * Add/Update store on-chain wallet object link
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  \OpenAPI\Client\Model\AddOnChainWalletObjectLinkRequest $add_on_chain_wallet_object_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletLinkAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'][0])
    {
        $returnType = '';
        $request = $this->storeOnChainWalletsAddOrUpdateOnChainWalletLinkRequest($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsAddOrUpdateOnChainWalletLink'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  \OpenAPI\Client\Model\AddOnChainWalletObjectLinkRequest $add_on_chain_wallet_object_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletLinkRequest($payment_method_id, $store_id, $object_id, $object_type, $add_on_chain_wallet_object_link_request, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletLink'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink'
            );
        }

        // verify the required parameter 'object_id' is set
        if ($object_id === null || (is_array($object_id) && count($object_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_id when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink'
            );
        }

        // verify the required parameter 'object_type' is set
        if ($object_type === null || (is_array($object_type) && count($object_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_type when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink'
            );
        }

        // verify the required parameter 'add_on_chain_wallet_object_link_request' is set
        if ($add_on_chain_wallet_object_link_request === null || (is_array($add_on_chain_wallet_object_link_request) && count($add_on_chain_wallet_object_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_on_chain_wallet_object_link_request when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($object_id !== null) {
            $resourcePath = str_replace(
                '{' . 'objectId' . '}',
                ObjectSerializer::toPathValue($object_id),
                $resourcePath
            );
        }
        // path params
        if ($object_type !== null) {
            $resourcePath = str_replace(
                '{' . 'objectType' . '}',
                ObjectSerializer::toPathValue($object_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_on_chain_wallet_object_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_on_chain_wallet_object_link_request));
            } else {
                $httpBody = $add_on_chain_wallet_object_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletObjects
     *
     * Add/Update store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OnChainWalletObjectData $on_chain_wallet_object_data on_chain_wallet_object_data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletObjectData
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletObjects($payment_method_id, $store_id, $on_chain_wallet_object_data, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'][0])
    {
        list($response) = $this->storeOnChainWalletsAddOrUpdateOnChainWalletObjectsWithHttpInfo($payment_method_id, $store_id, $on_chain_wallet_object_data, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletObjectsWithHttpInfo
     *
     * Add/Update store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OnChainWalletObjectData $on_chain_wallet_object_data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletObjectData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletObjectsWithHttpInfo($payment_method_id, $store_id, $on_chain_wallet_object_data, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'][0])
    {
        $request = $this->storeOnChainWalletsAddOrUpdateOnChainWalletObjectsRequest($payment_method_id, $store_id, $on_chain_wallet_object_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletObjectData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletObjectData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletObjectData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletObjectsAsync
     *
     * Add/Update store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OnChainWalletObjectData $on_chain_wallet_object_data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletObjectsAsync($payment_method_id, $store_id, $on_chain_wallet_object_data, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'][0])
    {
        return $this->storeOnChainWalletsAddOrUpdateOnChainWalletObjectsAsyncWithHttpInfo($payment_method_id, $store_id, $on_chain_wallet_object_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsAddOrUpdateOnChainWalletObjectsAsyncWithHttpInfo
     *
     * Add/Update store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OnChainWalletObjectData $on_chain_wallet_object_data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletObjectsAsyncWithHttpInfo($payment_method_id, $store_id, $on_chain_wallet_object_data, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletObjectData';
        $request = $this->storeOnChainWalletsAddOrUpdateOnChainWalletObjectsRequest($payment_method_id, $store_id, $on_chain_wallet_object_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsAddOrUpdateOnChainWalletObjects'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\OnChainWalletObjectData $on_chain_wallet_object_data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsAddOrUpdateOnChainWalletObjectsRequest($payment_method_id, $store_id, $on_chain_wallet_object_data, string $contentType = self::contentTypes['storeOnChainWalletsAddOrUpdateOnChainWalletObjects'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects'
            );
        }

        // verify the required parameter 'on_chain_wallet_object_data' is set
        if ($on_chain_wallet_object_data === null || (is_array($on_chain_wallet_object_data) && count($on_chain_wallet_object_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $on_chain_wallet_object_data when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($on_chain_wallet_object_data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($on_chain_wallet_object_data));
            } else {
                $httpBody = $on_chain_wallet_object_data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsCreateOnChainTransaction
     *
     * Create store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateOnChainTransactionRequest $create_on_chain_transaction_request create_on_chain_transaction_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response
     */
    public function storeOnChainWalletsCreateOnChainTransaction($payment_method_id, $store_id, $create_on_chain_transaction_request, string $contentType = self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'][0])
    {
        list($response) = $this->storeOnChainWalletsCreateOnChainTransactionWithHttpInfo($payment_method_id, $store_id, $create_on_chain_transaction_request, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsCreateOnChainTransactionWithHttpInfo
     *
     * Create store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateOnChainTransactionRequest $create_on_chain_transaction_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsCreateOnChainTransactionWithHttpInfo($payment_method_id, $store_id, $create_on_chain_transaction_request, string $contentType = self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'][0])
    {
        $request = $this->storeOnChainWalletsCreateOnChainTransactionRequest($payment_method_id, $store_id, $create_on_chain_transaction_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsCreateOnChainTransactionAsync
     *
     * Create store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateOnChainTransactionRequest $create_on_chain_transaction_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsCreateOnChainTransactionAsync($payment_method_id, $store_id, $create_on_chain_transaction_request, string $contentType = self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'][0])
    {
        return $this->storeOnChainWalletsCreateOnChainTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $create_on_chain_transaction_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsCreateOnChainTransactionAsyncWithHttpInfo
     *
     * Create store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateOnChainTransactionRequest $create_on_chain_transaction_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsCreateOnChainTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $create_on_chain_transaction_request, string $contentType = self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StoreOnChainWalletsCreateOnChainTransaction200Response';
        $request = $this->storeOnChainWalletsCreateOnChainTransactionRequest($payment_method_id, $store_id, $create_on_chain_transaction_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsCreateOnChainTransaction'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  \OpenAPI\Client\Model\CreateOnChainTransactionRequest $create_on_chain_transaction_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsCreateOnChainTransactionRequest($payment_method_id, $store_id, $create_on_chain_transaction_request, string $contentType = self::contentTypes['storeOnChainWalletsCreateOnChainTransaction'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsCreateOnChainTransaction'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsCreateOnChainTransaction'
            );
        }

        // verify the required parameter 'create_on_chain_transaction_request' is set
        if ($create_on_chain_transaction_request === null || (is_array($create_on_chain_transaction_request) && count($create_on_chain_transaction_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_on_chain_transaction_request when calling storeOnChainWalletsCreateOnChainTransaction'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_on_chain_transaction_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_on_chain_transaction_request));
            } else {
                $httpBody = $create_on_chain_transaction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainFeeRate
     *
     * Get store on-chain wallet fee rate
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  float|null $block_target The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#39;s configured &#x60;RecommendedFeeBlockTarget&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletFeeRateData
     */
    public function storeOnChainWalletsGetOnChainFeeRate($payment_method_id, $store_id, $block_target = null, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainFeeRateWithHttpInfo($payment_method_id, $store_id, $block_target, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainFeeRateWithHttpInfo
     *
     * Get store on-chain wallet fee rate
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  float|null $block_target The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#39;s configured &#x60;RecommendedFeeBlockTarget&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletFeeRateData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainFeeRateWithHttpInfo($payment_method_id, $store_id, $block_target = null, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainFeeRateRequest($payment_method_id, $store_id, $block_target, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletFeeRateData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletFeeRateData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletFeeRateData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainFeeRateAsync
     *
     * Get store on-chain wallet fee rate
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  float|null $block_target The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#39;s configured &#x60;RecommendedFeeBlockTarget&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainFeeRateAsync($payment_method_id, $store_id, $block_target = null, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'][0])
    {
        return $this->storeOnChainWalletsGetOnChainFeeRateAsyncWithHttpInfo($payment_method_id, $store_id, $block_target, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainFeeRateAsyncWithHttpInfo
     *
     * Get store on-chain wallet fee rate
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  float|null $block_target The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#39;s configured &#x60;RecommendedFeeBlockTarget&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainFeeRateAsyncWithHttpInfo($payment_method_id, $store_id, $block_target = null, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletFeeRateData';
        $request = $this->storeOnChainWalletsGetOnChainFeeRateRequest($payment_method_id, $store_id, $block_target, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainFeeRate'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  float|null $block_target The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#39;s configured &#x60;RecommendedFeeBlockTarget&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainFeeRateRequest($payment_method_id, $store_id, $block_target = null, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainFeeRate'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainFeeRate'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainFeeRate'
            );
        }

        if ($block_target !== null && $block_target < 1) {
            throw new \InvalidArgumentException('invalid value for "$block_target" when calling StoreWalletOnChainApi.storeOnChainWalletsGetOnChainFeeRate, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/feerate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $block_target,
            'blockTarget', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObject
     *
     * Get store on-chain wallet object
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletObjectData
     */
    public function storeOnChainWalletsGetOnChainWalletObject($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainWalletObjectWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectWithHttpInfo
     *
     * Get store on-chain wallet object
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletObjectData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainWalletObjectWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletObjectData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletObjectData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletObjectData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectAsync
     *
     * Get store on-chain wallet object
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletObjectAsync($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'][0])
    {
        return $this->storeOnChainWalletsGetOnChainWalletObjectAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectAsyncWithHttpInfo
     *
     * Get store on-chain wallet object
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletObjectAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletObjectData';
        $request = $this->storeOnChainWalletsGetOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainWalletObject'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObject'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainWalletObject'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainWalletObject'
            );
        }

        // verify the required parameter 'object_id' is set
        if ($object_id === null || (is_array($object_id) && count($object_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_id when calling storeOnChainWalletsGetOnChainWalletObject'
            );
        }

        // verify the required parameter 'object_type' is set
        if ($object_type === null || (is_array($object_type) && count($object_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_type when calling storeOnChainWalletsGetOnChainWalletObject'
            );
        }



        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_neighbour_data,
            'includeNeighbourData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($object_id !== null) {
            $resourcePath = str_replace(
                '{' . 'objectId' . '}',
                ObjectSerializer::toPathValue($object_id),
                $resourcePath
            );
        }
        // path params
        if ($object_type !== null) {
            $resourcePath = str_replace(
                '{' . 'objectType' . '}',
                ObjectSerializer::toPathValue($object_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjects
     *
     * Get store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string[]|null $ids The ids of objects to fetch, if used, type should be specified (optional)
     * @param  string|null $type The type of object to fetch (optional)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletObjectData[]
     */
    public function storeOnChainWalletsGetOnChainWalletObjects($payment_method_id, $store_id, $ids = null, $type = null, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainWalletObjectsWithHttpInfo($payment_method_id, $store_id, $ids, $type, $include_neighbour_data, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectsWithHttpInfo
     *
     * Get store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string[]|null $ids The ids of objects to fetch, if used, type should be specified (optional)
     * @param  string|null $type The type of object to fetch (optional)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletObjectData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainWalletObjectsWithHttpInfo($payment_method_id, $store_id, $ids = null, $type = null, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainWalletObjectsRequest($payment_method_id, $store_id, $ids, $type, $include_neighbour_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletObjectData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletObjectData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletObjectData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectsAsync
     *
     * Get store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string[]|null $ids The ids of objects to fetch, if used, type should be specified (optional)
     * @param  string|null $type The type of object to fetch (optional)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletObjectsAsync($payment_method_id, $store_id, $ids = null, $type = null, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'][0])
    {
        return $this->storeOnChainWalletsGetOnChainWalletObjectsAsyncWithHttpInfo($payment_method_id, $store_id, $ids, $type, $include_neighbour_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletObjectsAsyncWithHttpInfo
     *
     * Get store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string[]|null $ids The ids of objects to fetch, if used, type should be specified (optional)
     * @param  string|null $type The type of object to fetch (optional)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletObjectsAsyncWithHttpInfo($payment_method_id, $store_id, $ids = null, $type = null, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletObjectData[]';
        $request = $this->storeOnChainWalletsGetOnChainWalletObjectsRequest($payment_method_id, $store_id, $ids, $type, $include_neighbour_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainWalletObjects'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string[]|null $ids The ids of objects to fetch, if used, type should be specified (optional)
     * @param  string|null $type The type of object to fetch (optional)
     * @param  bool|null $include_neighbour_data Whether or not you should include neighbour&#39;s node data in the result (ie, &#x60;links.objectData&#x60;) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainWalletObjectsRequest($payment_method_id, $store_id, $ids = null, $type = null, $include_neighbour_data = true, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletObjects'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainWalletObjects'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainWalletObjects'
            );
        }





        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_neighbour_data,
            'includeNeighbourData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletReceiveAddress
     *
     * Get store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $force_generate Whether to generate a new address for this request even if the previous one was not used (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletAddressData
     */
    public function storeOnChainWalletsGetOnChainWalletReceiveAddress($payment_method_id, $store_id, $force_generate = false, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainWalletReceiveAddressWithHttpInfo($payment_method_id, $store_id, $force_generate, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletReceiveAddressWithHttpInfo
     *
     * Get store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $force_generate Whether to generate a new address for this request even if the previous one was not used (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletAddressData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainWalletReceiveAddressWithHttpInfo($payment_method_id, $store_id, $force_generate = false, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, $force_generate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletAddressData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletAddressData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletAddressData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletReceiveAddressAsync
     *
     * Get store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $force_generate Whether to generate a new address for this request even if the previous one was not used (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletReceiveAddressAsync($payment_method_id, $store_id, $force_generate = false, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'][0])
    {
        return $this->storeOnChainWalletsGetOnChainWalletReceiveAddressAsyncWithHttpInfo($payment_method_id, $store_id, $force_generate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletReceiveAddressAsyncWithHttpInfo
     *
     * Get store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $force_generate Whether to generate a new address for this request even if the previous one was not used (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletReceiveAddressAsyncWithHttpInfo($payment_method_id, $store_id, $force_generate = false, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletAddressData';
        $request = $this->storeOnChainWalletsGetOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, $force_generate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainWalletReceiveAddress'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  bool|null $force_generate Whether to generate a new address for this request even if the previous one was not used (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, $force_generate = false, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletReceiveAddress'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainWalletReceiveAddress'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainWalletReceiveAddress'
            );
        }



        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_generate,
            'forceGenerate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletTransaction
     *
     * Get store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletTransactionData
     */
    public function storeOnChainWalletsGetOnChainWalletTransaction($payment_method_id, $store_id, $transaction_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainWalletTransactionWithHttpInfo($payment_method_id, $store_id, $transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletTransactionWithHttpInfo
     *
     * Get store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletTransactionData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainWalletTransactionWithHttpInfo($payment_method_id, $store_id, $transaction_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletTransactionAsync
     *
     * Get store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletTransactionAsync($payment_method_id, $store_id, $transaction_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'][0])
    {
        return $this->storeOnChainWalletsGetOnChainWalletTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletTransactionAsyncWithHttpInfo
     *
     * Get store on-chain wallet transaction
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $transaction_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletTransactionData';
        $request = $this->storeOnChainWalletsGetOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainWalletTransaction'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletTransaction'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainWalletTransaction'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainWalletTransaction'
            );
        }

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling storeOnChainWalletsGetOnChainWalletTransaction'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletUTXOs
     *
     * Get store on-chain wallet UTXOS
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletUTXOData[]
     */
    public function storeOnChainWalletsGetOnChainWalletUTXOs($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'][0])
    {
        list($response) = $this->storeOnChainWalletsGetOnChainWalletUTXOsWithHttpInfo($payment_method_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletUTXOsWithHttpInfo
     *
     * Get store on-chain wallet UTXOS
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletUTXOData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsGetOnChainWalletUTXOsWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'][0])
    {
        $request = $this->storeOnChainWalletsGetOnChainWalletUTXOsRequest($payment_method_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletUTXOData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletUTXOData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletUTXOData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletUTXOsAsync
     *
     * Get store on-chain wallet UTXOS
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletUTXOsAsync($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'][0])
    {
        return $this->storeOnChainWalletsGetOnChainWalletUTXOsAsyncWithHttpInfo($payment_method_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsGetOnChainWalletUTXOsAsyncWithHttpInfo
     *
     * Get store on-chain wallet UTXOS
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsGetOnChainWalletUTXOsAsyncWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletUTXOData[]';
        $request = $this->storeOnChainWalletsGetOnChainWalletUTXOsRequest($payment_method_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsGetOnChainWalletUTXOs'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsGetOnChainWalletUTXOsRequest($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsGetOnChainWalletUTXOs'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsGetOnChainWalletUTXOs'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsGetOnChainWalletUTXOs'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/utxos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsPatchOnChainWalletTransaction
     *
     * Patch store on-chain wallet transaction info
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  \OpenAPI\Client\Model\PatchOnChainTransactionRequest $patch_on_chain_transaction_request patch_on_chain_transaction_request (required)
     * @param  string|null $force Whether to update the label/comments even if the transaction does not yet exist (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletTransactionData
     */
    public function storeOnChainWalletsPatchOnChainWalletTransaction($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force = null, string $contentType = self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'][0])
    {
        list($response) = $this->storeOnChainWalletsPatchOnChainWalletTransactionWithHttpInfo($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsPatchOnChainWalletTransactionWithHttpInfo
     *
     * Patch store on-chain wallet transaction info
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  \OpenAPI\Client\Model\PatchOnChainTransactionRequest $patch_on_chain_transaction_request (required)
     * @param  string|null $force Whether to update the label/comments even if the transaction does not yet exist (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletTransactionData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsPatchOnChainWalletTransactionWithHttpInfo($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force = null, string $contentType = self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'][0])
    {
        $request = $this->storeOnChainWalletsPatchOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsPatchOnChainWalletTransactionAsync
     *
     * Patch store on-chain wallet transaction info
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  \OpenAPI\Client\Model\PatchOnChainTransactionRequest $patch_on_chain_transaction_request (required)
     * @param  string|null $force Whether to update the label/comments even if the transaction does not yet exist (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsPatchOnChainWalletTransactionAsync($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force = null, string $contentType = self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'][0])
    {
        return $this->storeOnChainWalletsPatchOnChainWalletTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsPatchOnChainWalletTransactionAsyncWithHttpInfo
     *
     * Patch store on-chain wallet transaction info
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  \OpenAPI\Client\Model\PatchOnChainTransactionRequest $patch_on_chain_transaction_request (required)
     * @param  string|null $force Whether to update the label/comments even if the transaction does not yet exist (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsPatchOnChainWalletTransactionAsyncWithHttpInfo($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force = null, string $contentType = self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletTransactionData';
        $request = $this->storeOnChainWalletsPatchOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsPatchOnChainWalletTransaction'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $transaction_id The transaction id to fetch (required)
     * @param  \OpenAPI\Client\Model\PatchOnChainTransactionRequest $patch_on_chain_transaction_request (required)
     * @param  string|null $force Whether to update the label/comments even if the transaction does not yet exist (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsPatchOnChainWalletTransactionRequest($payment_method_id, $store_id, $transaction_id, $patch_on_chain_transaction_request, $force = null, string $contentType = self::contentTypes['storeOnChainWalletsPatchOnChainWalletTransaction'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsPatchOnChainWalletTransaction'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsPatchOnChainWalletTransaction'
            );
        }

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling storeOnChainWalletsPatchOnChainWalletTransaction'
            );
        }

        // verify the required parameter 'patch_on_chain_transaction_request' is set
        if ($patch_on_chain_transaction_request === null || (is_array($patch_on_chain_transaction_request) && count($patch_on_chain_transaction_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_on_chain_transaction_request when calling storeOnChainWalletsPatchOnChainWalletTransaction'
            );
        }



        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patch_on_chain_transaction_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patch_on_chain_transaction_request));
            } else {
                $httpBody = $patch_on_chain_transaction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletLink
     *
     * Remove store on-chain wallet object links
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $link_id The object id of the linked neighbour (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $link_type The object type of the linked neighbour (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeOnChainWalletsRemoveOnChainWalletLink($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'][0])
    {
        $this->storeOnChainWalletsRemoveOnChainWalletLinkWithHttpInfo($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, $contentType);
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletLinkWithHttpInfo
     *
     * Remove store on-chain wallet object links
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $link_id The object id of the linked neighbour (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $link_type The object type of the linked neighbour (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsRemoveOnChainWalletLinkWithHttpInfo($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'][0])
    {
        $request = $this->storeOnChainWalletsRemoveOnChainWalletLinkRequest($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletLinkAsync
     *
     * Remove store on-chain wallet object links
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $link_id The object id of the linked neighbour (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $link_type The object type of the linked neighbour (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsRemoveOnChainWalletLinkAsync($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'][0])
    {
        return $this->storeOnChainWalletsRemoveOnChainWalletLinkAsyncWithHttpInfo($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletLinkAsyncWithHttpInfo
     *
     * Remove store on-chain wallet object links
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $link_id The object id of the linked neighbour (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $link_type The object type of the linked neighbour (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsRemoveOnChainWalletLinkAsyncWithHttpInfo($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'][0])
    {
        $returnType = '';
        $request = $this->storeOnChainWalletsRemoveOnChainWalletLinkRequest($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsRemoveOnChainWalletLink'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $link_id The object id of the linked neighbour (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $link_type The object type of the linked neighbour (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsRemoveOnChainWalletLinkRequest($payment_method_id, $store_id, $link_id, $object_id, $link_type, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletLink'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }

        // verify the required parameter 'link_id' is set
        if ($link_id === null || (is_array($link_id) && count($link_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_id when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }

        // verify the required parameter 'object_id' is set
        if ($object_id === null || (is_array($object_id) && count($object_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_id when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }

        // verify the required parameter 'link_type' is set
        if ($link_type === null || (is_array($link_type) && count($link_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $link_type when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }

        // verify the required parameter 'object_type' is set
        if ($object_type === null || (is_array($object_type) && count($object_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_type when calling storeOnChainWalletsRemoveOnChainWalletLink'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links/{linkType}/{linkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'linkId' . '}',
                ObjectSerializer::toPathValue($link_id),
                $resourcePath
            );
        }
        // path params
        if ($object_id !== null) {
            $resourcePath = str_replace(
                '{' . 'objectId' . '}',
                ObjectSerializer::toPathValue($object_id),
                $resourcePath
            );
        }
        // path params
        if ($link_type !== null) {
            $resourcePath = str_replace(
                '{' . 'linkType' . '}',
                ObjectSerializer::toPathValue($link_type),
                $resourcePath
            );
        }
        // path params
        if ($object_type !== null) {
            $resourcePath = str_replace(
                '{' . 'objectType' . '}',
                ObjectSerializer::toPathValue($object_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletObject
     *
     * Remove store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeOnChainWalletsRemoveOnChainWalletObject($payment_method_id, $store_id, $object_id, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'][0])
    {
        $this->storeOnChainWalletsRemoveOnChainWalletObjectWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $contentType);
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletObjectWithHttpInfo
     *
     * Remove store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsRemoveOnChainWalletObjectWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'][0])
    {
        $request = $this->storeOnChainWalletsRemoveOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletObjectAsync
     *
     * Remove store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsRemoveOnChainWalletObjectAsync($payment_method_id, $store_id, $object_id, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'][0])
    {
        return $this->storeOnChainWalletsRemoveOnChainWalletObjectAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsRemoveOnChainWalletObjectAsyncWithHttpInfo
     *
     * Remove store on-chain wallet objects
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsRemoveOnChainWalletObjectAsyncWithHttpInfo($payment_method_id, $store_id, $object_id, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'][0])
    {
        $returnType = '';
        $request = $this->storeOnChainWalletsRemoveOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsRemoveOnChainWalletObject'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $object_id The object id to fetch (required)
     * @param  string $object_type The object type to fetch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsRemoveOnChainWalletObjectRequest($payment_method_id, $store_id, $object_id, $object_type, string $contentType = self::contentTypes['storeOnChainWalletsRemoveOnChainWalletObject'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsRemoveOnChainWalletObject'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsRemoveOnChainWalletObject'
            );
        }

        // verify the required parameter 'object_id' is set
        if ($object_id === null || (is_array($object_id) && count($object_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_id when calling storeOnChainWalletsRemoveOnChainWalletObject'
            );
        }

        // verify the required parameter 'object_type' is set
        if ($object_type === null || (is_array($object_type) && count($object_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $object_type when calling storeOnChainWalletsRemoveOnChainWalletObject'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($object_id !== null) {
            $resourcePath = str_replace(
                '{' . 'objectId' . '}',
                ObjectSerializer::toPathValue($object_id),
                $resourcePath
            );
        }
        // path params
        if ($object_type !== null) {
            $resourcePath = str_replace(
                '{' . 'objectType' . '}',
                ObjectSerializer::toPathValue($object_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletHistogram
     *
     * Get store on-chain wallet balance histogram
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistogramData
     */
    public function storeOnChainWalletsShowOnChainWalletHistogram($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'][0])
    {
        list($response) = $this->storeOnChainWalletsShowOnChainWalletHistogramWithHttpInfo($payment_method_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletHistogramWithHttpInfo
     *
     * Get store on-chain wallet balance histogram
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistogramData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsShowOnChainWalletHistogramWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'][0])
    {
        $request = $this->storeOnChainWalletsShowOnChainWalletHistogramRequest($payment_method_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HistogramData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HistogramData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistogramData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletHistogramAsync
     *
     * Get store on-chain wallet balance histogram
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletHistogramAsync($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'][0])
    {
        return $this->storeOnChainWalletsShowOnChainWalletHistogramAsyncWithHttpInfo($payment_method_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletHistogramAsyncWithHttpInfo
     *
     * Get store on-chain wallet balance histogram
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletHistogramAsyncWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HistogramData';
        $request = $this->storeOnChainWalletsShowOnChainWalletHistogramRequest($payment_method_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsShowOnChainWalletHistogram'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsShowOnChainWalletHistogramRequest($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletHistogram'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsShowOnChainWalletHistogram'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsShowOnChainWalletHistogram'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/histogram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletOverview
     *
     * Get store on-chain wallet overview
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletOverviewData
     */
    public function storeOnChainWalletsShowOnChainWalletOverview($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'][0])
    {
        list($response) = $this->storeOnChainWalletsShowOnChainWalletOverviewWithHttpInfo($payment_method_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletOverviewWithHttpInfo
     *
     * Get store on-chain wallet overview
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletOverviewData, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsShowOnChainWalletOverviewWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'][0])
    {
        $request = $this->storeOnChainWalletsShowOnChainWalletOverviewRequest($payment_method_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletOverviewData',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletOverviewData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletOverviewData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletOverviewAsync
     *
     * Get store on-chain wallet overview
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletOverviewAsync($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'][0])
    {
        return $this->storeOnChainWalletsShowOnChainWalletOverviewAsyncWithHttpInfo($payment_method_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletOverviewAsyncWithHttpInfo
     *
     * Get store on-chain wallet overview
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletOverviewAsyncWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletOverviewData';
        $request = $this->storeOnChainWalletsShowOnChainWalletOverviewRequest($payment_method_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsShowOnChainWalletOverview'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsShowOnChainWalletOverviewRequest($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletOverview'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsShowOnChainWalletOverview'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsShowOnChainWalletOverview'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletTransactions
     *
     * Get store on-chain wallet transactions
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string|null $label_filter Transaction label to filter by (optional)
     * @param  int|null $limit Maximum number of transactions to return (optional)
     * @param  int|null $skip Number of transactions to skip from the start (optional)
     * @param  \OpenAPI\Client\Model\TransactionStatus[]|null $status_filter Statuses to filter the transactions with (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OnChainWalletTransactionData[]
     */
    public function storeOnChainWalletsShowOnChainWalletTransactions($payment_method_id, $store_id, $label_filter = null, $limit = null, $skip = null, $status_filter = null, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'][0])
    {
        list($response) = $this->storeOnChainWalletsShowOnChainWalletTransactionsWithHttpInfo($payment_method_id, $store_id, $label_filter, $limit, $skip, $status_filter, $contentType);
        return $response;
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletTransactionsWithHttpInfo
     *
     * Get store on-chain wallet transactions
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string|null $label_filter Transaction label to filter by (optional)
     * @param  int|null $limit Maximum number of transactions to return (optional)
     * @param  int|null $skip Number of transactions to skip from the start (optional)
     * @param  \OpenAPI\Client\Model\TransactionStatus[]|null $status_filter Statuses to filter the transactions with (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OnChainWalletTransactionData[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsShowOnChainWalletTransactionsWithHttpInfo($payment_method_id, $store_id, $label_filter = null, $limit = null, $skip = null, $status_filter = null, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'][0])
    {
        $request = $this->storeOnChainWalletsShowOnChainWalletTransactionsRequest($payment_method_id, $store_id, $label_filter, $limit, $skip, $status_filter, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OnChainWalletTransactionData[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OnChainWalletTransactionData[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletTransactionsAsync
     *
     * Get store on-chain wallet transactions
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string|null $label_filter Transaction label to filter by (optional)
     * @param  int|null $limit Maximum number of transactions to return (optional)
     * @param  int|null $skip Number of transactions to skip from the start (optional)
     * @param  \OpenAPI\Client\Model\TransactionStatus[]|null $status_filter Statuses to filter the transactions with (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletTransactionsAsync($payment_method_id, $store_id, $label_filter = null, $limit = null, $skip = null, $status_filter = null, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'][0])
    {
        return $this->storeOnChainWalletsShowOnChainWalletTransactionsAsyncWithHttpInfo($payment_method_id, $store_id, $label_filter, $limit, $skip, $status_filter, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsShowOnChainWalletTransactionsAsyncWithHttpInfo
     *
     * Get store on-chain wallet transactions
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string|null $label_filter Transaction label to filter by (optional)
     * @param  int|null $limit Maximum number of transactions to return (optional)
     * @param  int|null $skip Number of transactions to skip from the start (optional)
     * @param  \OpenAPI\Client\Model\TransactionStatus[]|null $status_filter Statuses to filter the transactions with (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsShowOnChainWalletTransactionsAsyncWithHttpInfo($payment_method_id, $store_id, $label_filter = null, $limit = null, $skip = null, $status_filter = null, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OnChainWalletTransactionData[]';
        $request = $this->storeOnChainWalletsShowOnChainWalletTransactionsRequest($payment_method_id, $store_id, $label_filter, $limit, $skip, $status_filter, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsShowOnChainWalletTransactions'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string|null $label_filter Transaction label to filter by (optional)
     * @param  int|null $limit Maximum number of transactions to return (optional)
     * @param  int|null $skip Number of transactions to skip from the start (optional)
     * @param  \OpenAPI\Client\Model\TransactionStatus[]|null $status_filter Statuses to filter the transactions with (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsShowOnChainWalletTransactionsRequest($payment_method_id, $store_id, $label_filter = null, $limit = null, $skip = null, $status_filter = null, string $contentType = self::contentTypes['storeOnChainWalletsShowOnChainWalletTransactions'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsShowOnChainWalletTransactions'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsShowOnChainWalletTransactions'
            );
        }






        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label_filter,
            'labelFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_filter,
            'statusFilter', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOnChainWalletsUnReserveOnChainWalletReceiveAddress
     *
     * UnReserve last store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeOnChainWalletsUnReserveOnChainWalletReceiveAddress($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'][0])
    {
        $this->storeOnChainWalletsUnReserveOnChainWalletReceiveAddressWithHttpInfo($payment_method_id, $store_id, $contentType);
    }

    /**
     * Operation storeOnChainWalletsUnReserveOnChainWalletReceiveAddressWithHttpInfo
     *
     * UnReserve last store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOnChainWalletsUnReserveOnChainWalletReceiveAddressWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'][0])
    {
        $request = $this->storeOnChainWalletsUnReserveOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOnChainWalletsUnReserveOnChainWalletReceiveAddressAsync
     *
     * UnReserve last store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsUnReserveOnChainWalletReceiveAddressAsync($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'][0])
    {
        return $this->storeOnChainWalletsUnReserveOnChainWalletReceiveAddressAsyncWithHttpInfo($payment_method_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOnChainWalletsUnReserveOnChainWalletReceiveAddressAsyncWithHttpInfo
     *
     * UnReserve last store on-chain wallet address
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOnChainWalletsUnReserveOnChainWalletReceiveAddressAsyncWithHttpInfo($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'][0])
    {
        $returnType = '';
        $request = $this->storeOnChainWalletsUnReserveOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'
     *
     * @param  string $payment_method_id The payment method id of the payment method to update (required)
     * @param  string $store_id The store ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOnChainWalletsUnReserveOnChainWalletReceiveAddressRequest($payment_method_id, $store_id, string $contentType = self::contentTypes['storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'][0])
    {

        // verify the required parameter 'payment_method_id' is set
        if ($payment_method_id === null || (is_array($payment_method_id) && count($payment_method_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_method_id when calling storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling storeOnChainWalletsUnReserveOnChainWalletReceiveAddress'
            );
        }


        $resourcePath = '/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_method_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentMethodId' . '}',
                ObjectSerializer::toPathValue($payment_method_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storeId' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
